---
sidebar_position: 1
---

# 基础算法

## 快速排序

时间复杂度$O(nlogn)$

1. 找一个随机数 `X` 为分界点，`arr[l]、arr[r]、arr[(l+r/2)]`等
2. 调整区间，`X` 左边都比它小，右边都比它大
3. 递归处理左右

```cpp
void quick_sort(int q[], int l, int r)
{
    if (l >= r) return;//递归终止
    //使用的do while，需要在数组的两端之外开始进行
    //尽量不要使用边界作为中值x，会产生边界问题
    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while (i < j)
    {
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j), quick_sort(q, j + 1, r);	//递归左边和右边
}
```

#### [练习-第k个数](https://www.acwing.com/problem/content/788/)

**题目**：给定一个长度为n的整数数列，以及一个整数 k，请用快速选择算法求出数列从小到大排序后的第 k个数

**时间复杂度**$O(n)$

$n+n/2+n/4+n/8...=n(1+1/2+1/4+1/8+...)<=2n$

**解法：**

1. 找到分界点x
2. 调整区间，`X` 左边都比它小，右边都比它大
3. 用指针和k比较，判断递归左部还是右部(比快排少递归了一半多数据)

```cpp
const int N = 1e6;
int n,k;
int q[N];
int quick_sort(int l,int r,int k){
    if(l>=r)    return q[l];		//q[l]为最终结果
    int x=q[(l+r)/2],i=l-1,j=r+1;	
    while(i<j){
        while(q[++ i] < x);
        while(q[-- j] > x);
        if (i < j)
            swap(q[i],q[j]);
    }
    int sl=j-l+1;					//sl为一次排序后 左部长度
    if(k<=j) quick_sort(l,j,k);
    quick_sort(j+1,r,k-sl);			//要遍历右部，同样更改k值为k-sl，局部变量覆盖全局变量
}
int main(){
    scanf("%d %d",&n,&k);
    for(int i=0;i<n;i++)	scanf("%d",&q[i]);
    cout << quick_sort(0,n-1,k);
    return 0;
}
```

---

## 归并排序

1. 确定分界点，取数组中间位置 $mid = (l+r)/2$
2. 递归排序左部，和右部
3. 归并，合二为一

```cpp
void merge_sort(int q[], int l, int r)
{
    if (l >= r) return;		//只有一个数，递归终止

    int mid = l + r >> 1;	
    //递归排序！（将序列一直分，拆封成单个，即为有序）
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);

    int k = 0, i = l, j = mid + 1;	
    while (i <= mid && j <= r)	//较小的数放到前面
        if (q[i] <= q[j]) tmp[k ++ ] = q[i ++ ];	
        else tmp[k ++ ] = q[j ++ ];
	//扫尾
    while (i <= mid) tmp[k ++ ] = q[i ++ ];
    while (j <= r) tmp[k ++ ] = q[j ++ ];
	//，物归原主排序好的tmp数组覆盖原数组
    for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```

#### [练习-788. 逆序对的数量](https://www.acwing.com/problem/content/description/790/)

**题目**：给定一个长度为 n 的整数数列，请你计算数列中的逆序对的数量。

逆序对的定义如下：对于数列的第 i 个和第 j 个元素，如果满足 i<ji<j 且 a[i]>a[j]，则其为一个逆序对；否则不是。

```cpp {11}
LL merge_sort(int l,int r){
    if(l>=r)    return 0;
    int mid = l+r>>1;
    //递归排序！（将序列一直分，拆封成单个，即为有序）
    LL res = merge_sort(l,mid) + merge_sort(mid+1,r);
    int i=l,j=mid+1,k=0;
    while(i<=mid && j<=r){
        if(q[i]<=q[j])   temp[k++] = q[i++];
        else{
            //每次把右侧的数置入temp，说明q[i]~q[mid]的数都能和q[i]组成逆序对
            res += mid - i + 1;
            temp[k++] = q[j++];
        }    
    }
    //扫尾
    while(i<=mid)   temp[k++] = q[i++];
    while(j<=r)    temp[k++] = q[j++];
    //物归原主
    for(i=l,j=0;i<=r;i++,j++) q[i] = temp[j];
    return res;
}
```

---

## 二分

:::tip

在一个大区间内部，每次都会分为两个区间，结果只有一个区间满足答案，进而不断二分

:::

### 整数二分-模板

**模板1**

```cpp
bool check(int x) {/* ... */} // 检查x是否满足某种性质
// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
//求左边界（也就是例题中数的第一次出现的位置）的点
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;    // check()判断mid是否满足性质
        else l = mid + 1;
    }
    return l;
}
```

**模板2**

```cpp
// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：
// 求右边界（也就是例题中数的最后一次出现的位置）的点
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
```

#### [练习-789. 数的范围](https://www.acwing.com/problem/content/791/)

**题目：**给定一个按照**升序**排列的长度为 n 的整数数组，以及 q 个查询。

对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 0 开始计数）。

如果数组中不存在该元素，则返回 `-1 -1`

```cpp
int n,m,k;
int q[N];
int main(){   
    scanf("%d %d",&n,&m);
    for(int i=0;i<n;i++) scanf("%d",&q[i]);  
    while(m--){
        scanf("%d",&k);
        int i=0,j=n-1;
        while(i<j){
            int mid = i+j>>1;
            if(q[mid] >= k) j=mid;  //q[mid]一定在k的右边，答案一定在左边，取左j=mid
            else i=mid+1;
        }
        if(k!=q[i]) cout<<"-1 -1"<<endl;
        else{
            cout << i << " ";
            int i0=0,j0=n-1;
            while(i0<j0){
                int mid=i0+j0+1>>1; //向上取整,模板2
                if(q[mid] <= k) i0=mid; //q[mid]在左边，q[mid]也可能是k，i0要取到mid,才能保证取得最右边的值
                else j0=mid-1;
            } 
            cout << i0 << endl;
        }
    }
    return 0;
}
```



### 浮点数二分-模板

```cpp
bool check(double x) {/* ... */} // 检查x是否满足某种性质

double bsearch_3(double l, double r)
{
    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求
    while (r - l > eps)
    {
        double mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid;
    }
    return l;
}
```

#### [练习-790. 数的三次方根](https://www.acwing.com/problem/content/792/)

**题目：**给定一个浮点数 `n`，求它的三次方根。结果保留 6 位小数

```cpp
const double exp=1e-8;
int main(){
    double x;
    scanf("%lf",&x);
    double l=-100,r=100;	//类型保持一直为double，否则类型转化超时
    while(r-l > exp){
        double mid = (l+r)/2;
        if(mid * mid * mid >= x) r=mid;
        else l=mid;
    }
    printf("%.6lf",l);
    return 0;
}
```

