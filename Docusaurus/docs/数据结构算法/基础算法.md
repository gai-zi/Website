---
sidebar_position: 1
---

# 基础算法

## 快速排序

时间复杂度$O(nlogn)$

1. 找一个随机数 `X` 为分界点，`arr[l]、arr[r]、arr[(l+r/2)]`等
2. 调整区间，`X` 左边都比它小，右边都比它大
3. 递归处理左右

```cpp
void quick_sort(int q[], int l, int r)
{
    if (l >= r) return;//递归终止
    //使用的do while，需要在数组的两端之外开始进行
    //尽量不要使用边界作为中值x，会产生边界问题
    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while (i < j)
    {
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j), quick_sort(q, j + 1, r);	//递归左边和右边
}
```

#### [练习-第k个数](https://www.acwing.com/problem/content/788/)

**题目**：给定一个长度为n的整数数列，以及一个整数 k，请用快速选择算法求出数列从小到大排序后的第 k个数

**时间复杂度**$O(n)$

$n+n/2+n/4+n/8...=n(1+1/2+1/4+1/8+...)<=2n$

**解法：**

1. 找到分界点x
2. 调整区间，`X` 左边都比它小，右边都比它大
3. 用指针和k比较，判断递归左部还是右部(比快排少递归了一半多数据)

```cpp
const int N = 1e6;
int n,k;
int q[N];
int quick_sort(int l,int r,int k){
    if(l>=r)    return q[l];		//q[l]为最终结果
    int x=q[(l+r)/2],i=l-1,j=r+1;	
    while(i<j){
        while(q[++ i] < x);
        while(q[-- j] > x);
        if (i < j)
            swap(q[i],q[j]);
    }
    int sl=j-l+1;					//sl为一次排序后 左部长度
    if(k<=j) quick_sort(l,j,k);
    quick_sort(j+1,r,k-sl);			//要遍历右部，同样更改k值为k-sl，局部变量覆盖全局变量
}
int main(){
    scanf("%d %d",&n,&k);
    for(int i=0;i<n;i++)	scanf("%d",&q[i]);
    cout << quick_sort(0,n-1,k);
    return 0;
}
```

---

## 归并排序

1. 确定分界点，取数组中间位置 $mid = (l+r)/2$
2. 递归排序左部，和右部
3. 归并，合二为一

```cpp
void merge_sort(int q[], int l, int r)
{
    if (l >= r) return;		//只有一个数，递归终止

    int mid = l + r >> 1;	
    //递归排序！（将序列一直分，拆封成单个，即为有序）
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);

    int k = 0, i = l, j = mid + 1;	
    while (i <= mid && j <= r)	//较小的数放到前面
        if (q[i] <= q[j]) tmp[k ++ ] = q[i ++ ];	
        else tmp[k ++ ] = q[j ++ ];
	//扫尾
    while (i <= mid) tmp[k ++ ] = q[i ++ ];
    while (j <= r) tmp[k ++ ] = q[j ++ ];
	//，物归原主排序好的tmp数组覆盖原数组
    for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```

#### [练习-788. 逆序对的数量](https://www.acwing.com/problem/content/description/790/)

**题目**：给定一个长度为 n 的整数数列，请你计算数列中的逆序对的数量。

逆序对的定义如下：对于数列的第 i 个和第 j 个元素，如果满足 i<ji<j 且 a[i]>a[j]，则其为一个逆序对；否则不是。

```cpp {11}
LL merge_sort(int l,int r){
    if(l>=r)    return 0;
    int mid = l+r>>1;
    //递归排序！（将序列一直分，拆封成单个，即为有序）
    LL res = merge_sort(l,mid) + merge_sort(mid+1,r);
    int i=l,j=mid+1,k=0;
    while(i<=mid && j<=r){
        if(q[i]<=q[j])   temp[k++] = q[i++];
        else{
            //每次把右侧的数置入temp，说明q[i]~q[mid]的数都能和q[i]组成逆序对
            res += mid - i + 1;
            temp[k++] = q[j++];
        }    
    }
    //扫尾
    while(i<=mid)   temp[k++] = q[i++];
    while(j<=r)    temp[k++] = q[j++];
    //物归原主
    for(i=l,j=0;i<=r;i++,j++) q[i] = temp[j];
    return res;
}
```

---

## 二分

:::tip

在一个大区间内部，每次都会分为两个区间，结果只有一个区间满足答案，进而不断二分

:::

### 整数二分-模板

**模板1**

```cpp
bool check(int x) {/* ... */} // 检查x是否满足某种性质
// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
//求左边界（也就是例题中数的第一次出现的位置）的点
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;    // check()判断mid是否满足性质
        else l = mid + 1;
    }
    return l;
}
```

**模板2**

```cpp
// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：
// 求右边界（也就是例题中数的最后一次出现的位置）的点
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
```

#### [练习-789. 数的范围](https://www.acwing.com/problem/content/791/)

**题目：**给定一个按照**升序**排列的长度为 n 的整数数组，以及 q 个查询。

对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 0 开始计数）。

如果数组中不存在该元素，则返回 `-1 -1`

```cpp
int n,m,k;
int q[N];
int main(){   
    scanf("%d %d",&n,&m);
    for(int i=0;i<n;i++) scanf("%d",&q[i]);  
    while(m--){
        scanf("%d",&k);
        int i=0,j=n-1;
        while(i<j){
            int mid = i+j>>1;
            if(q[mid] >= k) j=mid;  //q[mid]一定在k的右边，答案一定在左边，取左j=mid
            else i=mid+1;
        }
        if(k!=q[i]) cout<<"-1 -1"<<endl;
        else{
            cout << i << " ";
            int i0=0,j0=n-1;
            while(i0<j0){
                int mid=i0+j0+1>>1; //向上取整,模板2
                if(q[mid] <= k) i0=mid; //q[mid]在左边，q[mid]也可能是k，i0要取到mid,才能保证取得最右边的值
                else j0=mid-1;
            } 
            cout << i0 << endl;
        }
    }
    return 0;
}
```



### 浮点数二分-模板

```cpp
bool check(double x) {/* ... */} // 检查x是否满足某种性质

double bsearch_3(double l, double r)
{
    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求
    while (r - l > eps)
    {
        double mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid;
    }
    return l;
}
```

#### [练习-790. 数的三次方根](https://www.acwing.com/problem/content/792/)

**题目：**给定一个浮点数 `n`，求它的三次方根。结果保留 6 位小数

```cpp
const double exp=1e-8;
int main(){
    double x;
    scanf("%lf",&x);
    double l=-100,r=100;	//类型保持一直为double，否则类型转化超时
    while(r-l > exp){
        double mid = (l+r)/2;
        if(mid * mid * mid >= x) r=mid;
        else l=mid;
    }
    printf("%.6lf",l);
    return 0;
}
```

## 高精度

> 大数在数组中逆序存放，比如'123456'中6放在数组第'0'位

- 大整数相加

```cpp
vector<int> add(vector<int> &A, vector<int> &B)
{
    vector<int> C;
    int t = 0; //进位标识符
    for (int i = 0; i < A.size() || i < B.size(); i++){
        if (i < A.size())	t += A[i];
        if (i < B.size())	t += B[i];
        C.push_back(t % 10);
        t = t / 10;
    }
    if (t)	C.push_back(1);	//进位+1
    return C;
}
```

- 大整数相减

```cpp
//默认A、B不等且A>=B
vector<int> sub(vector<int> &A, vector<int> &B)
{
    vector<int> C;
    int t = 0; //进位标识符
    for (int i = 0; i < A.size(); i++){
        t = A[i] - t;
        if (i < B.size())	t -= B[i];
        C.push_back((t + 10) % 10);
        if (t < 0)	t = 1;
        else	t = 0;
    }
    //去掉前导0，123-120=3(而不是033)
    while (C.size() > 1 && C.back() == 0)	C.pop_back();
    return C;
}
```

- 大整数相乘

  - 高精度 X 低精度

  ```cpp
  //不同于常规乘法，循环中被乘数的每一位去乘以乘数b
  //高精度的整数A 乘以 低精度整数b
  vector<long long> mul(vector<long long> A, int b)
  {
      vector<long long> C;
      long long t = 0;
      for (int i = 0; i < A.size() || t; i++)
      {
          t += A[i] * b;
          C.push_back(t % 10);
          t /= 10;
      }
      return C;
  }
  ```

  - 高精度 X 高精度

  ![](.\src\高精度X高精度.png)

  ```cpp
  vector<long long> mulAXB(vector<long long> A, vector<long long> B)
  {
      //开辟空间
      vector<long long> C(A.size() + B.size() + 10, 0);
      for (int i = 0; i < A.size(); i++)
          for (int j = 0; j < B.size(); j++)
              C[i + j] += A[i] * B[j];
      //处理进位
      for (int i = 0; i < C.size() - 1; i++){
          C[i + 1] += C[i] / 10;
          C[i] %= 10;
      }
      //消除前导0
      while (C.size() > 1 && C.back() == 0)
          C.pop_back();
      return C;
  }
  ```

- 大整数相除（高精度/低精度）：求商和余数

```cpp
vector<int> div(vector<int> &A, int b, int &r){
    vector<int> C;
    r = 0;
    for (int i = A.size() - 1; i >= 0; i--){
        r = r * 10 + A[i];
        C.push_back(r / b);
        r %= b;
    }
    reverse(C.begin(), C.end());
    while (C.size() > 1 && C.back() == 0)
        C.pop_back();
    return C;
}
```

## 前缀和 与 差分

> **注意**：数组下标0位置存0，从下标为1处开始存放数据

### 前缀和

**一维前缀和**

```cpp{3}
int main()
{
ios::sync_with_stdio(false); //提高cin的速度，不能再使用scanf
    
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        cin >> a[i];
    //前缀和数组初始化
    for (int i = 1; i <= n; i++)
        S[i] = S[i - 1] + a[i];
    while (m--)
    {
        int l, r;
        cin >> l >> r;
        cout << S[r] - S[l - 1] << endl;
    }
    return 0;
}
```

**二维前缀和**

> 记公式

求矩阵内部前缀和公式：

![](.\src\二维前缀和公式.png)

求特定区域前缀和公式：

![](.\src\求特定区域前缀和公式.png)

#### [练习-796. 子矩阵的和](https://www.acwing.com/problem/content/798/)

**题目：**输入一个 n 行 m 列的整数矩阵，再输入 q 个询问，每个询问包含四个整数 x1,y1,x2,y2，表示一个子矩阵的左上角坐标和右下角坐标。对于每个询问输出子矩阵中所有数的和。

```cpp
int main(){
    cin >> n >> m >> q;
    for (int i = 1; i <= n; i++)
        for (int k = 1; k <= m; k++)
            cin >> a[i][k];
    //求矩阵前缀和
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            S[i][j] = S[i - 1][j] + S[i][j - 1] - S[i - 1][j - 1] + a[i][j];
    while (q--){
        int x1, x2, y1, y2;
        cin >> x1 >> y1 >> x2 >> y2;
        cout << S[x2][y2] - S[x1 - 1][y2] - S[x2][y1 - 1] + S[x1 - 1][y1 - 1] << endl;
    }
    return 0;
}
```

### 差分

**一维差分**

> A[N]存放原数组，B[N]存放差分数组,$A[i+1]-A[i] = B[i]$
>
> eg：
>
> - A[N] = {1,3,5,8,10}
> - B[N] = {1,2,2,3,2}

