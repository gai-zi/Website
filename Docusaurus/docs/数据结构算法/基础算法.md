---
sidebar_position: 1
---

# 基础算法

## 快速排序

时间复杂度$O(nlogn)$

1. 找一个随机数 `X` 为分界点，`arr[l]、arr[r]、arr[(l+r/2)]`等
2. 调整区间，`X` 左边都比它小，右边都比它大
3. 递归处理左右

```cpp
void quick_sort(int q[], int l, int r)
{
    if (l >= r) return;//递归终止
    //使用的do while，需要在数组的两端之外开始进行
    //尽量不要使用边界作为中值x，会产生边界问题
    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while (i < j)
    {
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j), quick_sort(q, j + 1, r);	//递归左边和右边
}
```

#### [练习-第k个数](https://www.acwing.com/problem/content/788/)

**题目**：给定一个长度为n的整数数列，以及一个整数 k，请用快速选择算法求出数列从小到大排序后的第 k个数

**时间复杂度**$O(n)$

$n+n/2+n/4+n/8...=n(1+1/2+1/4+1/8+...)<=2n$

**解法：**

1. 找到分界点x
2. 调整区间，`X` 左边都比它小，右边都比它大
3. 用指针和k比较，判断递归左部还是右部(比快排少递归了一半多数据)

```cpp
const int N = 1e6;
int n,k;
int q[N];
int quick_sort(int l,int r,int k){
    if(l>=r)    return q[l];		//q[l]为最终结果
    int x=q[(l+r)/2],i=l-1,j=r+1;	
    while(i<j){
        while(q[++ i] < x);
        while(q[-- j] > x);
        if (i < j)
            swap(q[i],q[j]);
    }
    int sl=j-l+1;					//sl为一次排序后 左部长度
    if(k<=j) quick_sort(l,j,k);
    quick_sort(j+1,r,k-sl);			//要遍历右部，同样更改k值为k-sl，局部变量覆盖全局变量
}
int main(){
    scanf("%d %d",&n,&k);
    for(int i=0;i<n;i++)	scanf("%d",&q[i]);
    cout << quick_sort(0,n-1,k);
    return 0;
}
```

---

## 归并排序

1. 确定分界点，取数组中间位置 $mid = (l+r)/2$
2. 递归排序左部，和右部
3. 归并，合二为一

```cpp
void merge_sort(int q[], int l, int r)
{
    if (l >= r) return;		//只有一个数，递归终止

    int mid = l + r >> 1;	
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);

    int k = 0, i = l, j = mid + 1;	
    while (i <= mid && j <= r)	//较小的数放到前面
        if (q[i] <= q[j]) tmp[k ++ ] = q[i ++ ];	
        else tmp[k ++ ] = q[j ++ ];
	//将剩下没置入tmp的数字全部放入即可
    while (i <= mid) tmp[k ++ ] = q[i ++ ];
    while (j <= r) tmp[k ++ ] = q[j ++ ];
	//排序好的tmp数组覆盖原数组
    for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```

---

## 二分

:::tip

在一个大区间内部，每次都会分为两个区间，结果只有一个区间满足答案，进而不断二分

:::

### 整数二分-模板

```cpp
bool check(int x) {/* ... */} // 检查x是否满足某种性质
// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;    // check()判断mid是否满足性质
        else l = mid + 1;
    }
    return l;
}
// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
```

#### [练习-789. 数的范围](https://www.acwing.com/problem/content/791/)

**题目：**给定一个按照**升序**排列的长度为 n 的整数数组，以及 q 个查询。

对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 0 开始计数）。

如果数组中不存在该元素，则返回 `-1 -1`

### 浮点数二分-模板

```cpp
bool check(double x) {/* ... */} // 检查x是否满足某种性质

double bsearch_3(double l, double r)
{
    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求
    while (r - l > eps)
    {
        double mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid;
    }
    return l;
}
```

#### [练习-790. 数的三次方根](https://www.acwing.com/problem/content/792/)

**题目：**给定一个浮点数 `n`，求它的三次方根。结果保留 6 位小数
