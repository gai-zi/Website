---
sidebar_position: 1
---

## 快速排序

### [785. 快速排序](https://www.acwing.com/problem/content/description/787/)

时间复杂度$O(nlogn)$

1. 找一个随机数 `X` 为分界点，`arr[l]、arr[r]、arr[(l+r/2)]`等
2. 调整区间，`X` 左边都比它小，右边都比它大
3. 递归处理左右
   1. 开辟两个数组空间，分别放置小于`X`的数和大于`X`数，再合并
   2. 如下代码所示

```C++
const int N = 1e6;	//数组长度直接按题目要求开辟
int n;				
int q[N];

void quick_sort(int q[], int l, int r)
{
    if (l >= r) return;			//递归终止
    //使用的do while，需要在数组的两端之外开始进行
    //尽量不要使用边界作为中值x，会产生边界问题
    int x = q[(l + r) / 2], i = l - 1, j = r + 1;	
    while (i < j)
    {
        do i++; while (x > q[i]);
        do j--; while (x < q[j]);
        if (i < j) swap(q[i], q[j]);	//交换
    }
    quick_sort(q, l, j);				//递归左边，j在左 i在右
    quick_sort(q, j + 1, r);			//递归右边
}

int main()
{
    scanf("%d", &n);
    for (int i = 0; i < n; i++) scanf("%d", &q[i]);
    quick_sort(q, 0, n - 1);
    for (int i = 0; i < n; i++) cout << q[i] << " ";
    return 0;
}
```

## [786. 第k个数 - 快速选择算法](https://www.acwing.com/activity/content/problem/content/820/)

$n+n/2+n/4+n/8...=n(1+1/2+1/4+1/8+...)<=2n$

时间复杂度$O(n)$

1. 找到分界点x
2. 调整区间，`X` 左边都比它小，右边都比它大
3. 用指针和k比较，判断递归左部还是右部(比快排少递归了一半多数据)

```C++
const int N = 1e6;
int n,k;
int q[N];
int quick_sort(int l,int r,int k){
    if(l>=r)    return q[l];		//q[l]为最终结果
    int x=q[(l+r)/2],i=l-1,j=r+1;	
    while(i<j){
        while(q[++ i] < x);
        while(q[-- j] > x);
        if (i < j)
            swap(q[i],q[j]);
    }
    int sl=j-l+1;					//sl为一次排序后 左部长度
    if(k<=j) quick_sort(l,j,k);
    quick_sort(j+1,r,k-sl);			//要遍历右部，同样更改k值为k-sl，局部变量覆盖全局变量
}
int main(){
    scanf("%d %d",&n,&k);
    for(int i=0;i<n;i++)	scanf("%d",&q[i]);
    cout << quick_sort(0,n-1,k);
    return 0;
}
```

