---
sidebar_position: 2
---

# 数据结构

## 单链表

> 笔试时多用数组模拟链表，因为动态链表的方法过慢.
>
> 使用数组进行链表操作时，删除节点会不会释放空间（笔试算法非工程项目无需考虑此多余空间）

```cpp
int head, e[N], ne[N], idx;
// 头指针  值    指针  索引
void init()     //初始化
{ 
    head = -1;   //头指针指向链尾
    idx = 0;    //索引为0
}
void add_to_head(int x)   // 在头指针后插入元素x
{
    e[idx] = x;             //先将下标为idx的节点中存入x的值
    ne[idx] = head;        //idx的指向头结点指向
    head = idx;             //头结点指向idx
    idx++;                  //索引自增
}
//将x插到下标是k的点的后面
void add(int k, int x)   
{  
    e[idx] = x;             //将下标为idx的节点中存入x
    ne[idx] = ne[k];       //idx节点中指针指向k节点所指向的节点
    ne[k] = idx;          //k节点指向idx节点
    idx++;                  //索引自增
}
//将下标是k的后面的点删掉
void remove(int k)          
{
    ne[k] = ne[ne[k]];  //k节点指向后面的后面节点
}
```

> **邻接表**：多用于存储图和树

## 双链表

> 多用来优化问题

```cpp
int l[N],r[N],a[N],idx;
// 0是左端点，1是右端点
r[0] = 1, l[1] = 0;
idx = 2;
// 在节点k的右边插入一个数x
void insert(int k, int x){
    a[idx] = x;
    l[idx] = k;
    r[idx] = r[k];
    l[r[k]] = idx;
    r[k] = idx;
    idx++;
}
//删除位置k的数
void del(int k){
    l[r[k]] = l[k];
    r[l[k]] = r[k];
}
```

## 栈

> 先进后出；数组模拟；

```cpp
//  栈      栈顶
int stk[N],idx = 0;

void push(int x){stk[++idx] = x;}
void pop(){idx--;}
bool empty(){
    if(idx <= 0) return true;
    else return false;
}
int query(){
    return stk[idx];
}
```

## 队列

```cpp
//  队列  队头 队尾
int q[N], hh = 0, tt = -1;

void push(int x){ q[++tt] = x; }

void pop(){ hh++; }

bool empty(){
    if(hh > tt) return true;
    else return false;
}

int query(){ return q[hh]; }
```

## 单调栈

> 栈中元素是单调的，解决特定问题

### [练习-830. 单调栈](https://www.acwing.com/problem/content/832/)

**题目**：给定一个长度为`N`的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 $-1$。

**主要思想**：设定一个**单调栈**，每次遍历只会添加比x小的数，或为空直接添加，保证栈的单调性；进而在栈中寻找一个比x小的数。

**时间复杂度**：每个元素**最多**进栈一次，出栈一次，所以算法时间复杂度$O(n)$

```cpp
const int N = 10010;
int stk[N], tt; //栈

int main(){
    int n, x;
    scanf("%d", &n);
    
    while(n--){
        scanf("%d", &x);
        //栈中存在大于x的数，则出栈寻找更小的（x左边比x小的第一个数）
        while(tt && stk[tt] >= x)   tt--;   	//如果删没了，说明没有更小的数了 
        if(tt)  printf("%d ", stk[tt]);
        else printf("-1 ");
        
        stk[++tt] = x;		//入栈的x肯定比x小，或者栈空直接添加
    }
    return 0;
}
```

## 单调队列

解决**滑动窗口**类问题

### [练习-154. 滑动窗口](https://www.acwing.com/problem/content/156/)

**题目**：给定一个大小为$n\leq 10^6$的数组。有一个大小为$k$的滑动窗口，它从数组的最左边移动到最右边。你只能在窗口中看到$k$个数字。每次滑动窗口向右移动一个位置。

确定滑动窗口位于每个位置时，窗口中的最大值和最小值。

**主要思想**：

- 保证**(双端)队列单调**
- **队列中数据都在窗口中**，满足单调性
- 将当前元素下标加入队尾
- 满足条件则输出结果

```cpp
//单调队列,存入的是a[N]的下标
//a[N]数据
int q[N], a[N];
//首，尾
int hh,tt;
int n, k;

int main(){
	...
    hh = 0, tt = -1;
    for(int i=0;i<n;i++){
        scanf("%d", &a[i]); 
        if(hh <= tt && i-k+1 > q[hh])   hh++;   //若队首出窗口，则队首hh++
        while(hh <= tt && a[q[tt]] >= a[i]) tt--;   //若队尾不单调，tt--
        q[++tt] = i;                            //存入队尾，且a[i]一定大于q[tt]
        
        if(i+1 >= k) printf("%d ", a[q[hh]]);	//输出最小
    }
   ...
}
```

## KMP



## `Trie`

## 并查集

## 堆

## 哈希表

