---
sidebar_position: 2
---

# 数据结构

## 单链表

> 笔试时多用数组模拟链表，因为动态链表的方法过慢.
>
> 使用数组进行链表操作时，删除节点会不会释放空间（笔试算法非工程项目无需考虑此多余空间）

```cpp
int head, e[N], ne[N], idx;
// 头指针  值    指针  索引
void init()     //初始化
{ 
    head = -1;   //头指针指向链尾
    idx = 0;    //索引为0
}
void add_to_head(int x)   // 在头指针后插入元素x
{
    e[idx] = x;             //先将下标为idx的节点中存入x的值
    ne[idx] = head;        //idx的指向头结点指向
    head = idx;             //头结点指向idx
    idx++;                  //索引自增
}
//将x插到下标是k的点的后面
void add(int k, int x)   
{  
    e[idx] = x;             //将下标为idx的节点中存入x
    ne[idx] = ne[k];       //idx节点中指针指向k节点所指向的节点
    ne[k] = idx;          //k节点指向idx节点
    idx++;                  //索引自增
}
//将下标是k的后面的点删掉
void remove(int k)          
{
    ne[k] = ne[ne[k]];  //k节点指向后面的后面节点
}
```

> **邻接表**：多用于存储图和树

## 双链表

> 多用来优化问题

```cpp
int l[N],r[N],a[N],idx;
// 0是左端点，1是右端点
r[0] = 1, l[1] = 0;
idx = 2;
// 在节点k的右边插入一个数x
void insert(int k, int x){
    a[idx] = x;
    l[idx] = k;
    r[idx] = r[k];
    l[r[k]] = idx;
    r[k] = idx;
    idx++;
}
//删除位置k的数
void del(int k){
    l[r[k]] = l[k];
    r[l[k]] = r[k];
}
```

## 栈

1:00:00

## 队列

## 单调栈

## 单调队列

## KMP

## `Trie`

## 并查集

## 堆

## 哈希表

