---
sidebar_position: 5
---

# 动态规划

## 背包问题

- **状态表示**：需要几维来表示状态（背包问题最基础有二维 '体积' 和 ‘价值' ）
  - 集合
    1. 所有选法全部罗列
    2. 根据条件设定集合：只从前$i$个物品选、总体积$<V$
  - 属性：$Max$(价值最大)、$Min$(代价最小)、数量
- **状态计算**：$dp(i,j)$集合划分为$2$个集合
  - $dp(i-1,j)$：不包含$i$，从$1\sim i-1$中选，体积为$j$
  - $dp(i-1,j-v_i)+w_i$：包含$i$，整个体积都减去$v_i$(空出$v_i$的体积)，再加上现在$w_i$的价值
  - 最后求以上两个集合的最大值$MAX(dp(i-1,j),dp(i-1,j-v_i)+w_i)$

### [0-1背包问题](https://www.acwing.com/problem/content/2/)

**题目**：有$N$件物品和一个容量是$V$的背包。**每件物品只能使用一次**。

第$i$件物品的体积是$v_i$，价值是$w_i$。

求解将哪些物品装入背包，可使这些物品的总体积不超过d

#### 二维状态解法

1. **`dp[i][j]`状态定义**：表示**前$i$个物品，背包容量$j$下的<u>最优状态</u>(最大价值)**

   当前状态依赖于之前的状态，从`dp[0][0]`开始决策，有$N$件物品，每次对第$i$个物品进行决策，状态`dp[i][j]`不断由之前的最优状态得出

2. **状态计算**

   - 当前背包**容量不够**(`j < v[i]`)，无法进行选择，前$i$个物品的最优解(最大价值)即为前$i-1$个物品的最优解

   `dp[i][j]=dp[i-1][j]`

   - 当前**背包容量够**，可以进行选择，因为需要判断选不选第$i$个物品
     - **选**：`dp[i][j] = dp[i-1][j-v[i]] + w[i]`（选入第$i$个物品，就需要割掉$1$个物品并空出`v[i]`的体积，找到$i-1$个物品并空出体积后的最优解`f[i-1][j-v[i]]`，然后` + w[i]`）
     - **不选**：`dp[i][j] = dp[i-1][j]`
     - 取选与不选的**最大价值**为最优解：`max(dp[i-1][j-v[i]] + w[i], dp[i-1][j])`

```cpp
const int MAX = 1010;
int num, volume;   //物品数， 背包容量
int v[MAX];         //体积
int w[MAX];         //价值
int dp[MAX][MAX];   //dp[i][j], j体积下前i个物品的最大价值 

int main(){
    cin >> num >> volume;
    for(int i=1;i<=num;i++) cin >> v[i] >> w[i];
    //枚举每个最优解，每个最优解都由前序最优解得出
    //第0行不需要求解，因为0个物品的最大价值也是0
    for(int i=1;i<=num;i++)
        for(int j=1;j<=volume;j++){
            //不能装，价值等同于i-1个物品；能装，需要进行决策
            if(j < v[i])  dp[i][j] = dp[i-1][j];
            else dp[i][j] = max( dp[i-1][j], dp[i-1][j-v[i]] + w[i] );
        }
    cout << dp[num][volume];
    
    return 0;
}
```

#### [一维状态解法](https://www.acwing.com/solution/content/1374/)

将状态`dp[i][j]`优化到一维`dp[j]`，实际上只需要做一个**等价变形**。

为什么可以这样变形呢？我们定义的状态`dp[i][j]`可以求得任意合法的$i$与$j$最优解，但题目只需要求得最终状态`dp[n][m]`，因此我们只需要一维的空间来更新状态。

- **状态`dp[j]`定义**：$N$件物品，背包容量$j$下的最优解。
- **注意枚举背包容量$j$必须从$m$开始**。
- **为什么一维情况下枚举背包容量需要逆序**？在二维情况下，状态`dp[i][j]`是由上一轮$i - 1$的状态得来的，`dp[i][j]`与`dp[i - 1][j]`是独立的。而优化到一维后，如果我们还是正序，则有`dp[较小体积]`更新到`dp[较大体积]`，则有可能本应该用第$i-1$轮的状态却用的是第$i$轮的状态。
- 例如，一维状态第$i$轮对体积为$3$的物品进行决策，则`dp[7]`由`dp[4]`更新而来，这里的`dp[4]`正确应该是`dp[i - 1][4]`，但从小到大枚举$j$这里的`dp[4]`在第$i$轮计算却变成了`dp[i][4]`。**当逆序枚举背包容量$j$时**，我们求`dp[7]`同样由`dp[4]`更新，但由于是逆序，这里的`dp[4]`还没有在第$i$轮计算，所以此时实际计算的`dp[4]`仍然是`dp[i - 1][4]`。
- 简单来说，一维情况正序更新状态`dp[j]`需要用到前面计算的状态已经被「污染」，逆序则不会有这样的问题。

**状态转移方程**为：`f[j] = max(f[j], f[j - v[i]] + w[i]`。

```cpp
for(int i = 1; i <= n; i++) 
    for(int j = m; j >= 0; j--){
        if(j < v[i]) 
            dp[i][j] = dp[i - 1][j];  // 优化前
            dp[j] = dp[j];            // 优化后，该行自动成立，可省略。
        else    
            dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i]); //优化前
            dp[j] = max(dp[j], dp[j - v[i]] + w[i]);                //优化后
    }
```

实际上，只有当枚举的背包容量 $\geq v[i]$ 时才会更新状态，因此我们可以修改循环终止条件**进一步优化**。

```cpp
for(int i = 1; i <= n; i++)
    for(int j = m; j >= v[i]; j--)  			//从大到小枚举
       	dp[j] = max(dp[j], dp[j - v[i]] + w[i]);
```

**关于状态`dp[j]`的补充说明**

二维下的状态定义`dp[i][j]`是前$i$件物品，背包容量$j$下的最大价值。一维下，少了前$i$件物品这个维度，我们的代码中决策到第$i$件物品（循环到第$i$轮），`dp[j]`就是前$i$轮已经决策的物品且背包容量$j$下的最大价值。

因此当执行完循环结构后，由于已经决策了所有物品，`dp[j]`就是所有物品背包容量$j$下的最大价值。即一维`dp[j]`等价于二维`dp[n][j]`。

### [完全背包问题](https://www.acwing.com/problem/content/3/)

**题目**：有$N$种物品和一个容量是$V$的背包，**每种物品都有无限件可用**。

第$i$种物品的体积是$vi$，价值是$wi$。

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
输出最大价值。

**分析状态**： 

- **状态表示**：定义一个二维数组来罗列 在背包重量为$j$的情况下，前$i$个物品中任意进行选择的最优解

  - **集合**：在前$i$个物品中任意选择，$j$重量下的选法

  - **属性**：`Max`价值最大
  - **`dp[i]j]`定义**：在前$i$个物品中选择，$j$重量下的最优解

- **状态计算**：

  可以选$k$个$i$物品， `k*v[i] <= j`

  - 需要进行抉择` max(dp[i][j], dp[i-1][j-v[i]*k]+w[i]*k)`
    - 当$k=0$时刻，`dp[i][j] = dp[i-1][j]`，说明最开始选择前$i$个物品的最优解 == 选择前$i-1$个物品的最优解
    - **选or不选**：当$k>0$时，`dp[i][j]`需要**抉择**，选择添加此$k$个$i$物品为价值大，还是原来的价值`dp[i][j]`大

#### 朴素算法$O(nm^2)$

```cpp
int n, m;			//n物品数量， m背包容量
int v[N], w[N];		//volume体积， wealth价值
int dp[N][N];		

void FullBag(){
    for(int i=1;i<=n;i++)					//枚举物品
        for(int j=1;j<=m;j++)				//枚举体积
            for(int k = 0;k*v[i]<=j;k++)	//枚举k个i物品
                dp[i][j] = max(dp[i][j], dp[i-1][j-v[i]*k]+w[i]*k);
}
```

#### **二维状态解法**

优化朴素算法，**推导公式**如下
$$
f[i,j] = Max(f[i-1,j], f[i-1,j-v_i]+w_i, f[i-1,j-2v_i]+2w_i, ...)\\
f[i,j-v_i] = Max(f[i-1,j-v_i], f[i-1,j-2v_i]+w_i, f[i-1,j-3v_i]+3w_i, ...)
$$
**综合后**：$f(i,j)=Max(f[i-1,j],f[i,j-v_i]+w_i)$

```cpp
void FullBag(){
    for(int i=1;i<=n;i++)					//枚举物品
        for(int j=1;j<=m;j++){				//枚举体积
            dp[i][j] = dp[i-1][j];	
            if(j>=v[i]) dp[i][j] = max(dp[i][j], dp[i][j-v[i]]+w[i]);
        }
}
```

**输入输出解释**：

```cpp
输入：
4 5		//物品数量 背包容量
1 2		//物体1的 体积 和 价值
2 4
3 4
4 5
    
输出：
2 4 6 8 10
2 4 6 8 10		
2 4 6 8 10
2 4 6 8 10
    
/*
i=1,j=4时，dp[1][4]=8
1. dp[1][4]=dp[0][4]=0
2. j>=v[i] 4>2 进行决策
3. d[1][4]=0, dp[1][4-v[i]]+w[1] = dp[1][4-1]+w[1] = dp[1][3]+w[i]
	一个物品可选，价值为2的最优解，再加上1物品的重量：相当于取四个物品1
4. 取dp[1][4-v[i]]+w[1]
*/
```

#### 一维状态解法

**等价变形**

- **状态`dp[j]`定义**：$N$件物品，背包容量$j$下的最优解。
- **注意枚举背包容量$j$必须从`v[i]`开始**。
- **为什么一维情况下枚举背包容量不需要逆序**？因为是从小到大枚举重量，当我们进行决策时`dp[j-v[i]]`中的下标`j-v[i]`一定小于`j`，`j-v[i]` 处的最优解为上一层的数据，相当于二维的`dp[i][j-1]+w[i]`与`dp[i][j]`进行比较，不会发生污染当前最优解数组的情况。

**状态转移方程**为：`dp[j] = max(dp[j], dp[j-v[i]]+w[i])`。

```cpp
int n, m;			//n物品数量， m背包容量
int v[N], w[N];		//volume体积， wealth价值
int dp[N];		//dp[i][j], j体积下任意数量前i个物品的最大价值

void FullBag(){
    for(int i=1;i<=n;i++)					//枚举物品
        for(int j=v[i];j<=m;j++)			//从小到大枚举体积
             dp[j] = max(dp[j], dp[j-v[i]]+w[i]);
}
```

> 0-1背包 和 完全背包 的一维状态解法，二层循环条件的区别：
>
> 二者的执行语句都为`dp[j] = max(dp[j], dp[j-v[i]]+w[i]);`
>
> - 0-1背包的二层循环：`for(int j = m; j >= v[i]; j--)`
>
>   `i`层需要用`i-1`层来更新
>
> - 完全背包的二层循环：`for(int j=v[i];j<=m;j++)`
>
>   `j`只能从小到大，主要看**状态方程的推导公式**

### [多重背包问题](https://www.acwing.com/problem/content/4/)

**题目**：有$N$种物品和一个容量是$V$的背包。

第$i$种物品**最多有$s_i$件**，每件体积是$v_i$，价值是$w_i$。

求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。
输出最大价值。

**分析状态**： 

- **状态表示**

  - **集合**：在前$i$个物品中每个物品不多于$s_i$的选择，$j$重量下的选法

  - **属性**：`Max`价值最大
  - **`dp[i]j]`定义**：在前$i$个物品中每个物品不多于$s_i$的选择，$j$重量下的最优解

- **状态计算**：

  可以选$k$个$i$物品， `k*v[i] <= j`

  - 需要进行抉择` max(dp[i][j], dp[i-1][j-v[i]*k]+w[i]*k)`
    - 当$k=0$时刻，`dp[i][j] = dp[i-1][j]`，说明最开始选择前$i$个物品的最优解 == 选择前$i-1$个物品的最优解
    - **选or不选**：当$k>0$ && $k*v_i\leq s_i$时，`dp[i][j]`需要**抉择**，选择添加此$k$个$i$物品为价值大，还是原来的价值`dp[i][j]`大

#### 朴素算法$O(nm^2)$

> 与完全背包问题前两层循环相同，第三层循环可以多一个判断

```cpp
int n, m;					//n物品数量， m背包容量
int v[N], w[N], s[N];		//volume体积， wealth价值, s[N]表示i种物品最多有s[i]件
int dp[N][N];		

void FullBag(){
    for(int i=1;i<=n;i++)					//枚举物品
        for(int j=1;j<=m;j++)				//枚举体积
            for(int k = 0;k*v[i]<=j && k<=s[i];k++)	//枚举k个i物品
                dp[i][j] = max(dp[i][j], dp[i-1][j-v[i]*k]+w[i]*k);
}
```

#### 二进制优化

**状态转移方程**

相比于完全背包状态转移方程，多处一项，原因在于完全背包方程对于每种物品没有选择个数的限制，所以只要够用就一直选。

```cpp
1. f[i , j ] = max( f[i-1,j] ,f[i-1,j-v]+w ,f[i-1,j-2v]+2w ,....., f[i-1,j-Sv]+Sw, )
2. f[i , j-v]= max(           f[i-1,j-v]   ,f[i-1,j-2v]+w  ,....., f[i-1,j-s*v]+(s-1)w, f[i-1,j-(s+1)v]+s*w )
```

**注意**：不能直接用完全背包的优化方式来优化多重背包问题

​	原因在于：不能用`f[i, j-v]`来表示`f[i,j]`的后$s-1$项，因为$1$式比$2$式的末尾多出一个`f[i-1,j-(s+1)v]+s*w`，无法根据不完整的$2$式与`f[i-1,j]`比较求出`f[i,j]`的最大值

> 二进制优化思维就是：现在给出一堆苹果和$10$个箱子，选出$n$个苹果。将这一堆苹果分别按照$1,2,4,8,16,.....512$分到$10$个箱子里，那么由于任何一个数字$x ∈[1,1024]$
> 都可以从这$10$个箱子里的苹果数量表示出来，但是这样选择的次数就是$ ≤10$次 。
>
> 这样利用二进制优化，时间复杂度就从$O(n^3)$降到$O(n^2logS)$,从$4*10^9$降到了$2*10^7$。

```cpp
int main(){
    int cnt = 0;
    
    for(int i=0;i<=n;i++){
        int a,b,s;		//体积、价值、数量
        cin >> a >> b >> s;
        int k = 1;
        //二进制优化
        while(k<=s){
            cnt++;
            v[cnt] = a*k;
            w[cnt] = b*k;
            s -= k;
            k *= 2;
        }
        if(s > 0){
            cnt ++;
            v[cnt] = a*s;
            w[cnt] = b*s;
        }
    }
    n = cnt;			//将原来的n二进制优化后的数量
    
    for(int i=1;i<=n;i++)
        for(int j=m;j>=v[i];j--)
            dp[j] = max( dp[j], dp[j-v[i]]+w[i] );
            
    cout << dp[m];
    return 0;
}
```



01:42:29
