---
sidebar_position: 5
---

# 动态规划

## 背包问题

- **状态表示**：需要几维来表示状态（背包问题最基础有二维 '体积' 和 ‘价值' ）
  - 集合
    1. 所有选法全部罗列
    2. 根据条件设定集合：只从前$i$个物品选、总体积$<V$
  - 属性：$Max$(价值最大)、$Min$(代价最小)、数量
- **状态计算**：$f(i,j)$集合划分为$2$个集合
  - $f(i-1,j)$：不包含$i$，从$1\sim i-1$中选，体积为$j$
  - $f(i-1,j-v_i)+w_i$：包含$i$，整个体积都减去$v_i$(空出$v_i$的体积)，再加上现在$w_i$的价值
  - 最后求以上两个集合的最大值$MAX(f(i-1,j),f(i-1,j-v_i)+w_i)$

### [0-1背包问题](https://www.acwing.com/problem/content/2/)

**题目**：有$N$件物品和一个容量是$V$的背包。**每件物品只能使用一次**。

第$i$件物品的体积是$v_i$，价值是$w_i$。

求解将哪些物品装入背包，可使这些物品的总体积不超过d

#### 二维状态解法

1. **`dp[i][j]`状态定义**：表示**前$i$个物品，背包容量$j$下的<u>最优状态</u>(最大价值)**

   当前状态依赖于之前的状态，从`dp[0][0]`开始决策，有$N$件物品，每次对第$i$个物品进行决策，状态`dp[i][j]`不断由之前的最优状态得出

2. **状态计算**

   - 当前背包**容量不够**(`j < v[i]`)，无法进行选择，前$i$个物品的最优解(最大价值)即为前$i-1$个物品的最优解

   `dp[i][j]=dp[i-1][j]`

   - 当前**背包容量够**，可以进行选择，因为需要判断选不选第$i$个物品
     - **选**：`dp[i][j] = dp[i-1][j-v[i]] + w[i]`（选入第$i$个物品，就需要割掉$1$个物品并空出`v[i]`的体积，找到$i-1$个物品并空出体积后的最优解`f[i-1][j-v[i]]`，然后` + w[i]`）
     - **不选**：`dp[i][j] = dp[i-1][j]`
     - 取选与不选的**最大价值**为最优解：`max(dp[i-1][j-v[i]] + w[i], dp[i-1][j])`

```cpp
const int MAX = 1010;
int num, volume;   //物品数， 背包容量
int v[MAX];         //体积
int w[MAX];         //价值
int dp[MAX][MAX];   //dp[i][j], j体积下前i个物品的最大价值 

int main(){
    cin >> num >> volume;
    for(int i=1;i<=num;i++) cin >> v[i] >> w[i];
    //枚举每个最优解，每个最优解都由前序最优解得出
    //第0行不需要求解，因为0个物品的最大价值也是0
    for(int i=1;i<=num;i++)
        for(int j=1;j<=volume;j++){
            //不能装，价值等同于i-1个物品；能装，需要进行决策
            if(j < v[i])  dp[i][j] = dp[i-1][j];
            else dp[i][j] = max( dp[i-1][j], dp[i-1][j-v[i]] + w[i] );
        }
    cout << dp[num][volume];
    
    return 0;
}
```

#### [一维状态解法](https://www.acwing.com/solution/content/1374/)

将状态`dp[i][j]`优化到一维`dp[j]`，实际上只需要做一个**等价变形**。

为什么可以这样变形呢？我们定义的状态`dp[i][j]`可以求得任意合法的$i$与$j$最优解，但题目只需要求得最终状态`dp[n][m]`，因此我们只需要一维的空间来更新状态。

- **状态`dp[j]`定义**：$N$件物品，背包容量$j$下的最优解。
- **注意枚举背包容量$j$必须从$m$开始**。
- **为什么一维情况下枚举背包容量需要逆序**？在二维情况下，状态`dp[i][j]`是由上一轮$i - 1$的状态得来的，`dp[i][j]`与`dp[i - 1][j]`是独立的。而优化到一维后，如果我们还是正序，则有`dp[较小体积]`更新到`dp[较大体积]`，则有可能本应该用第$i-1$轮的状态却用的是第$i$轮的状态。
- 例如，一维状态第$i$轮对体积为$3$的物品进行决策，则`dp[7]`由`dp[4]`更新而来，这里的`dp[4]`正确应该是`dp[i - 1][4]`，但从小到大枚举$j$这里的`dp[4]`在第$i$轮计算却变成了`dp[i][4]`。**当逆序枚举背包容量$j$时**，我们求`dp[7]`同样由`dp[4]`更新，但由于是逆序，这里的`dp[4]`还没有在第$i$轮计算，所以此时实际计算的`dp[4]`仍然是`dp[i - 1][4]`。
- 简单来说，一维情况正序更新状态`dp[j]`需要用到前面计算的状态已经被「污染」，逆序则不会有这样的问题。

**状态转移方程**为：`f[j] = max(f[j], f[j - v[i]] + w[i]`。

```cpp
for(int i = 1; i <= n; i++) 
    for(int j = m; j >= 0; j--)
    {
        if(j < v[i]) 
            dp[i][j] = dp[i - 1][j];  // 优化前
            dp[j] = dp[j];            // 优化后，该行自动成立，可省略。
        else    
            dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i]); //优化前
            dp[j] = max(dp[j], dp[j - v[i]] + w[i]);                //优化后
    } 
```

实际上，只有当枚举的背包容量 $\geq v[i]$ 时才会更新状态，因此我们可以修改循环终止条件进一步优化。

```cpp
for(int i = 1; i <= n; i++)
    for(int j = m; j >= v[i]; j--)  
       	dp[j] = max(dp[j], dp[j - v[i]] + w[i]);
```

**关于状态`dp[j]`的补充说明**

二维下的状态定义`dp[i][j]`是前$i$件物品，背包容量$j$下的最大价值。一维下，少了前$i$件物品这个维度，我们的代码中决策到第$i$件物品（循环到第$i$轮），`dp[j]`就是前$i$轮已经决策的物品且背包容量$j$下的最大价值。

因此当执行完循环结构后，由于已经决策了所有物品，`dp[j]`就是所有物品背包容量$j$下的最大价值。即一维`dp[j]`等价于二维`dp[n][j]`。

### 完全背包问题

时间46:00
