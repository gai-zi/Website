---
sidebar_position: 2
---

# 数据结构

## 单链表

> 笔试时多用数组模拟链表，因为动态链表的方法过慢.
>
> 使用数组进行链表操作时，删除节点会不会释放空间（笔试算法非工程项目无需考虑此多余空间）

```cpp
int head, e[N], ne[N], idx;
// 头指针  值    指针  索引
void init()     //初始化
{ 
    head = -1;   //头指针指向链尾
    idx = 0;    //索引为0
}
void add_to_head(int x)   // 在头指针后插入元素x
{
    e[idx] = x;             //先将下标为idx的节点中存入x的值
    ne[idx] = head;        //idx的指向头结点指向
    head = idx;             //头结点指向idx
    idx++;                  //索引自增
}
//将x插到下标是k的点的后面
void add(int k, int x)   
{  
    e[idx] = x;             //将下标为idx的节点中存入x
    ne[idx] = ne[k];       //idx节点中指针指向k节点所指向的节点
    ne[k] = idx;          //k节点指向idx节点
    idx++;                  //索引自增
}
//将下标是k的后面的点删掉
void remove(int k)          
{
    ne[k] = ne[ne[k]];  //k节点指向后面的后面节点
}
```

> **邻接表**：多用于存储图和树

## 双链表

> 多用来优化问题

```cpp
int l[N],r[N],a[N],idx;
// 0是左端点，1是右端点
r[0] = 1, l[1] = 0;
idx = 2;
// 在节点k的右边插入一个数x
void insert(int k, int x){
    a[idx] = x;
    l[idx] = k;
    r[idx] = r[k];
    l[r[k]] = idx;
    r[k] = idx;
    idx++;
}
//删除位置k的数
void del(int k){
    l[r[k]] = l[k];
    r[l[k]] = r[k];
}
```

## 栈

> 先进后出；数组模拟；

```cpp
//  栈      栈顶
int stk[N],idx = 0;

void push(int x){stk[++idx] = x;}
void pop(){idx--;}
bool empty(){
    if(idx <= 0) return true;
    else return false;
}
int query(){
    return stk[idx];
}
```

## 队列

```cpp
//  队列  队头 队尾
int q[N], hh = 0, tt = -1;

void push(int x){ q[++tt] = x; }

void pop(){ hh++; }

bool empty(){
    if(hh > tt) return true;
    else return false;
}

int query(){ return q[hh]; }
```

## 单调栈

> 栈中元素是单调的，解决特定问题

### [练习-830. 单调栈](https://www.acwing.com/problem/content/832/)

**题目**：给定一个长度为`N`的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 $-1$。

**主要思想**：设定一个**单调栈**，每次遍历只会添加比x小的数，或为空直接添加，保证栈的单调性；进而在栈中寻找一个比x小的数。

**时间复杂度**：每个元素**最多**进栈一次，出栈一次，所以算法时间复杂度$O(n)$

```cpp
const int N = 10010;
int stk[N], tt; //栈

int main(){
    int n, x;
    scanf("%d", &n);
    
    while(n--){
        scanf("%d", &x);
        //栈中存在大于x的数，则出栈寻找更小的（x左边比x小的第一个数）
        while(tt && stk[tt] >= x)   tt--;   	//如果删没了，说明没有更小的数了 
        if(tt)  printf("%d ", stk[tt]);
        else printf("-1 ");
        
        stk[++tt] = x;		//入栈的x肯定比x小，或者栈空直接添加
    }
    return 0;
}
```

## 单调队列

解决**滑动窗口**类问题

### [练习-154. 滑动窗口](https://www.acwing.com/problem/content/156/)

**题目**：给定一个大小为$n\leq 10^6$的数组。有一个大小为$k$的滑动窗口，它从数组的最左边移动到最右边。你只能在窗口中看到$k$个数字。每次滑动窗口向右移动一个位置。

确定滑动窗口位于每个位置时，窗口中的最大值和最小值。

**主要思想**：

- 保证**(双端)队列单调**
- **队列中数据都在窗口中**，满足单调性
- 将当前元素下标加入队尾
- 满足条件则输出结果

```cpp
//单调队列,存入的是a[N]的下标
//a[N]数据
int q[N], a[N];
//首，尾
int hh,tt;
int n, k;

int main(){
	...
    hh = 0, tt = -1;
    for(int i=0;i<n;i++){
        scanf("%d", &a[i]); 
        if(hh <= tt && i-k+1 > q[hh])   hh++;   //若队首出窗口，则队首hh++
        while(hh <= tt && a[q[tt]] >= a[i]) tt--;   //若队尾不单调，tt--
        q[++tt] = i;                            //存入队尾，且a[i]一定大于q[tt]
        
        if(i+1 >= k) printf("%d ", a[q[hh]]);	//输出最小
    }
   ...
}
```

## KMP

**字符串匹配算法**：设定短串**模板串为p[M]**，长串**模式串为s[N]**，在每次失配时，不是把p串往后移一位，而是把p串往后移动至下一次可以和前面部分匹配的位置，这样就可以跳过大多数的失配步骤。而每次p串移动的步数就是通过查找next[ ]数组确定的。

![](./src/KMP算法.png)

```cpp
cin >> m >> p+1 >> n >> s+1;

//求next[]数组
for(int i = 2, j = 0; i <= m; i++)
{
    //如果j有对应p串的元素， 且s[i] != p[j+1], 则失配， 移动p串
    //用while是由于移动后可能仍然失配，所以要继续移动直到匹配或整个p串移到后面（j = 0)
    while(j && p[i] != p[j+1]) j = ne[j];
    //当前元素匹配，j移向p串下一位
    if(p[i] == p[j+1]) j++;
    ne[i] = j;
}
//匹配操作
for(int i = 1, j = 0; i <= n; i++)
{
    while(j && s[i] != p[j+1]) j = ne[j];
    if(s[i] == p[j+1]) j++;
    if(j == m)  //满足匹配条件，打印开头下标, 从0开始
    {
        //匹配完成后的具体操作
        //如：输出以0开始的匹配子串的首字母下标
        //printf("%d ", i - m); (若从1开始，加1)
        j = ne[j];            //再次继续匹配
    }
}
```

## Trie树(字典树)

**`Trie`树**，又叫**字典树**、**前缀树（Prefix Tree）**、**单词查找树** 或 **键树**，是一种多叉树结构。

- 根节点不包含字符，除根节点外的每一个子节点都包含一个字符。
- 从根节点到**某一个节点**，路径上经过的字符连接起来，为该节点对应的字符串。
- 每个节点的所有子节点包含的字符互不相同。
- 通常在实现的时候，会在节点结构中设置一个**标志**，用来标记该结点处是否构成一个单词（关键字）。

> `Trie`树的核心思想是空间换时间，利用字符串的公共前缀来减少无谓的字符串比较以达到提高查询效率的目的。

```cpp
//数组模拟指针
int son[N][26]; //Tire树，因为最多26字母，所以数组纵列最多26
int count[N];   //计数
int idx = 0;        //指针
void insert(char* str){
    int q = 0;                              //根节点
    for(int i=0;str[i];i++){
        int u = str[i] - 'a';               //字符数字化
        if(!son[q][u])  son[q][u] = ++idx;  //节点为空，则置为idx
        q = son[q][u];                      //将q置为当前字符的节点指针
    }
    count[q]++;                             //此指针位置表示为一个字符串
}
//查询此字符串是否存在
int query(char* str){
    int q = 0;
    for(int i=0;str[i];i++){
        int u = str[i] - 'a';
        if(!son[q][u]) return 0;
        q = son[q][u];
    }
    return count[q];
}

```

### [练习-143. 最大异或对](https://www.acwing.com/activity/content/problem/content/884/)

## 并查集

并查集是一种**树型**的数据结构，用于处理一些**不相交集合的合并及查询**问题。
并查集的思想是用一个数组表示了整片森林（parent），树的根节点唯一标识了一个集合，我们只要找到了某个元素的的树根，就能确定它在哪个集合里。

每个集合用一棵树来表示，树根的编号就是整个集合的编号。每个节点存储它的父节点

## 堆

## 哈希表

