<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>Gaizi HomePage Blog</title>
        <link>https://gai-zi.github.io/Website/blog</link>
        <description>Gaizi HomePage Blog</description>
        <lastBuildDate>Tue, 05 Apr 2022 06:20:23 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <item>
            <title><![CDATA[ShooterGame说明文档]]></title>
            <link>https://gai-zi.github.io/Website/blog/ShooterGame说明文档/ShooterGame说明文档</link>
            <guid>/ShooterGame说明文档/ShooterGame说明文档</guid>
            <pubDate>Tue, 05 Apr 2022 06:20:23 GMT</pubDate>
            <description><![CDATA[项目源代码：gai-zi/ShooterGame: Aurora Studios (github.com)]]></description>
            <content:encoded><![CDATA[<blockquote><p>项目源代码：<a href="https://github.com/gai-zi/ShooterGame">gai-zi/ShooterGame: Aurora Studios (github.com)</a></p><p>打包游戏链接：<a href="https://share.weiyun.com/Lxd5HSw1">https://share.weiyun.com/Lxd5HSw1</a></p></blockquote><blockquote><p>UE版本：4.26</p><p>“如需要进入编辑器或导出应用查看实现效果，请选择&#x27;Highrise&#x27;地图”</p></blockquote><h2>游戏模式</h2><h3>炮台使用说明</h3><p> 1、玩家贴近炮台，准星对准炮台，按<strong>E键</strong>进入炮台，再按E键退出炮台继续操控原角色</p><p>2、<strong>旋转鼠标X轴</strong>，能够旋转炮台朝向方向</p><p>3、鼠标左键，发射<code>BP_Missile</code>导弹，遇到障碍物或玩家能够爆炸，产生范围伤害</p><p>4、使用炮台发射的导弹击杀玩家，能够获得双倍积分</p><p><img src="./src/%E7%82%AE%E5%8F%B0E.png"/></p><h3>功能一</h3><p>在场景中生成一个炮台</p><h4>实现效果</h4><p>创建&quot;BP_Turret&quot;蓝图继承自定义cpp类<code>ATurret</code>，置于场景中</p><p><img src="./src/%E5%9C%BA%E6%99%AF%E4%B8%AD%E7%82%AE%E5%8F%B0.png"/></p><p><img src="./src/%E7%82%AE%E5%8F%B0.png"/></p><h4>解决办法</h4><p>新建<strong>cpp类 ATurret</strong> 继承自 APawn</p><p>头文件声明必要的组件和属性，构造函数定义组件的属性</p><pre><code class="language-cpp">class SHOOTERGAME_API ATurret : public APawn
{
protected:
    UPROPERTY(EditAnywhere,Category=Component)
    UBoxComponent* BoxComponent;
    //最下层底座
    UPROPERTY(EditAnywhere,Category=Component)
    UStaticMeshComponent* Base;
    //可转底座
    UPROPERTY(EditAnywhere,Category=Component)
    UStaticMeshComponent* Base2;
    //发射器
    UPROPERTY(EditAnywhere,Category=Component)
    UStaticMeshComponent* Launcher;
    //相机组件
    UPROPERTY(EditAnywhere,Category=Component)
    UCameraComponent* OurCamera;
    //要生成的发射物蓝图
    TSubclassOf&lt;AShooterProjectile&gt; ProjectileClass;
}
</code></pre><p>BP_Turret蓝图继承此cpp类，将炮台的各个mesh、material赋值，填充新的组件，组件列表如下</p><p><img src="./src/%E7%82%AE%E5%8F%B0%E7%BB%84%E4%BB%B6%E5%88%97%E8%A1%A8.png"/></p><ul><li>Box Component：盒体碰撞体<ul><li>Base：炮台底部基座<ul><li>Base1：炮台支架，通过旋转此组件实现发射器左右旋转<ul><li>Launcher：发射器，从发射器内发射BP_Missile导弹</li><li>Our Camera：摄像机组件</li></ul></li></ul></li></ul></li></ul><h3>功能二</h3><p>炮台可以按照固定频率向固定方向发射炮弹</p><h4>实现效果</h4><p>进入炮台后，按鼠标左键能够发射导弹，<strong>间隔时间 1.5s</strong> ；</p><p><img src="./src/%E7%82%AE%E5%8F%B0%E5%8F%91%E5%B0%84.png"/></p><p><img src="./src/%E7%82%AE%E5%8F%B0%E5%8F%91%E5%B0%84%E7%89%A9%E7%88%86%E7%82%B8.png"/></p><p>自定义导弹状发射物<strong>BP_Missile</strong>蓝图，继承自 <code>AShooter Projectile</code>，导弹发射和运动能够实现多人同步</p><p><img src="./src/%E5%AF%BC%E5%BC%B9%E8%93%9D%E5%9B%BE%E7%BB%84%E4%BB%B6.png"/></p><p><img src="./src/%E7%AC%AC%E4%B8%89%E6%96%B9%E8%A7%86%E8%A7%92%E5%8F%91%E5%B0%84%E5%AF%BC%E5%BC%B9.png"/></p><h4>解决办法</h4><h4>导弹</h4><p>自定义蓝图 BP_Missile 继承自 Shooter Projectile </p><p>从网络资源中找到导弹的mesh，新建Static Mesh组件并添加成为BP_Missile的mesh</p><p><img src="./src/Missile_Mesh.png"/></p><p>定义Explpsion Template为ProjRocket_Explosion，添加爆炸粒子效果，当击中物体时产生爆炸</p><p><img src="./src/Missile_Effect.png"/></p><p>射线检测碰撞，发射一条从基坐标向运动方向的射线，如果触碰到就隐藏Mesh，再跟随根组件一起销毁，避免爆炸完后游戏世界还留有一个空壳炸弹的bug</p><p><img src="./src/Missile%E5%B0%84%E7%BA%BF%E6%A3%80%E6%B5%8B.png"/></p><h4>炮台Pawn控制发射</h4><p>Turret.h声明必要的属性和方法</p><pre><code class="language-cpp">//控制发射间隔参数
bool bCanFire = true;
float LastFireTime = 0.0f;
float FireRate = 1.5f;
//发射导弹
UFUNCTION()
void Fire();
</code></pre><p>设置鼠标左键按键绑定，绑定Fire()函数</p><pre><code class="language-cpp">PlayerInputComponent-&gt;BindAction(&quot;Fire&quot;,IE_Pressed,this,&amp;ATurret::Fire);
</code></pre><p>构造函数获取导弹蓝图BP_Missile</p><pre><code class="language-cpp">static ConstructorHelpers::FClassFinder&lt;AShooterProjectile&gt; ProjectileBP(TEXT(&quot;Blueprint&#x27;/Game/Blueprints/Weapons/BP_Missile.BP_Missile_C&#x27;&quot;));
if(ProjectileBP.Succeeded())
   ProjectileClass = ProjectileBP.Class;
</code></pre><p>Fire()函数内获取当前发射器旋转和坐标，来定义导弹出生位置的坐标和旋转；</p><p>如果条件允许，生成导弹</p><pre><code class="language-cpp">void ATurret::Fire()
{
   if(!bCanFire)  return;
   //获取炮台基座的世界坐标下的旋转
    ...//为各个组件的坐标相加，不过多赘述
   FRotator MissileWorldRotator = BaseWorldRotation + Base2WorldRotation;
   FVector MissileWorldLocation = BoxWorldLocation + BaseWorldLocation + Base2WorldLocation + LuncherWorldLocation;
   
   UWorld* World = GetWorld();   
   if(World)
   {
      FActorSpawnParameters SpawnParams;
      SpawnParams.Owner = this;
      SpawnParams.Instigator = GetInstigator();
      if(ProjectileClass)
      {
         AShooterProjectile* Proj= World-&gt;SpawnActor&lt;AShooterProjectile&gt;(ProjectileClass,MissileWorldLocation,MissileWorldRotator,SpawnParams);
      }
   }
   bCanFire = false;
   LastFireTime = 0.0f;
}
</code></pre><p>每帧计算当前时间间隔，若超过 1.5s 未发射导弹，将bCanFire置为true，每次发射后在Fire()方法中都会将bCanFire重置为false，重新计时。</p><pre><code class="language-cpp">void ATurret::Tick(float DeltaTime)
{
   Super::Tick(DeltaTime);
   
   if(!bCanFire &amp;&amp; LastFireTime &lt;= 1.5f)
   {
      LastFireTime += DeltaTime;
      if(LastFireTime &gt;= 1.5f) bCanFire = true;
   }
}
</code></pre><p>实现发射物按固定间隔1.5s发射导弹</p><h3>功能三</h3><p>炮弹可以击中角色并产生一定伤害</p><h4>实现效果</h4><p>导弹击中敌人产生爆炸效果，同时对敌人造成伤害，伤害值置为50，直接击败敌人</p><p><img src="./src/%E7%82%AE%E5%8F%B0%E5%87%BB%E8%B4%A5%E6%95%8C%E4%BA%BA.png"/></p><h4>解决办法</h4><p>通过基类 ShooterProjectile 方法，在发生碰撞后调用Explode()方法产生爆炸效果，并且调用<code>ApplyRadialDamage</code>方法造成伤害</p><pre><code class="language-cpp">UGameplayStatics::ApplyRadialDamage(this, WeaponConfig.ExplosionDamage, NudgedImpactLocation, WeaponConfig.ExplosionRadius, WeaponConfig.DamageType, TArray&lt;AActor*&gt;(), this, MyController.Get());
</code></pre><h3>功能四</h3><p>玩家可以让角色操控炮台调整左右方向，同时只能一个角色操控</p><h4>实现效果</h4><p>能够让玩家操控炮台并左右方向旋转发射器，同时只能有一个角色进入炮台</p><h4>解决办法</h4><h4>角色控制炮台</h4><p>ATurret类中定义<code>CurrentShooterCharacter</code>，用于存放当前控制自己的角色实例</p><pre><code class="language-cpp">//当前控制此炮台的角色
UPROPERTY(BlueprintReadWrite)
AShooterCharacter* CurrentShooterCharacter;
</code></pre><p>PlayerPawn蓝图中定义：</p><ul><li>PlayerPawn：当前角色的<code>AShooterCharacter</code>实例</li><li>PlayerPawnController：当前角色的控制器</li></ul><p>按E键，角色从当前相机位置向前发射一条射线，如果碰撞到了Turret，则可以控制该炮台，并且把这个炮台的<code>CurrentShooterCharacter</code>赋值为自身</p><p><img src="./src/E%E9%94%AE%E8%BF%9B%E5%85%A5%E7%82%AE%E5%8F%B0.png"/></p><p>Trace From Camera 方法中发射射线，并且检测是否碰撞的是炮台，将角色蓝图中的Turret赋值，并返回布尔值true</p><p><img src="./src/%E6%91%84%E5%83%8F%E6%9C%BA%E5%B0%84%E7%BA%BF.png"/></p><p>炮台中按E键会让控制器重新控制当前的人物角色<code>CurrentShooterCharacter</code></p><p><img src="./src/%E7%82%AE%E5%8F%B0%E9%87%8D%E6%96%B0%E6%93%8D%E6%8E%A7%E4%BA%BA%E7%89%A9.png"/></p><h4>实现炮台转向</h4><p>当前炮台拥有两个基座和一个发射器，需要调整左右方向，就需要更改 Base2 的Rotation Z值</p><p><img src="./src/%E6%97%8B%E8%BD%AC%E7%82%AE%E5%8F%B0.png"/></p><p>在Turret.h中声明TurnRight()方法，将其与鼠标X轴映射绑定，方法代码如下</p><pre><code class="language-cpp">void ATurret::TurnRight(float Value)
{
   //沿着Z轴旋转roll
   float Base2Yaw = Base2-&gt;GetRelativeRotation().Yaw;
   if(Value!=0.0f)
   {
      Base2-&gt;SetRelativeRotation(FRotator(0.0f,Base2Yaw+Value,0.0f));
   }
}
</code></pre><p>实现左右旋转炮台</p><h3>功能五</h3><p>玩家操控炮台击中敌方，导致死亡，玩家可以获得双倍积分</p><h4>实现效果</h4><p>枪械击杀敌人得分：2分</p><p><img src="./src/%E6%9E%AA%E6%A2%B0%E5%87%BB%E6%9D%80%E6%95%8C%E4%BA%BA%E5%BE%97%E5%88%86.png"/></p><p>炮台击杀敌人得分：4分</p><p><img src="./src/%E7%82%AE%E5%8F%B0%E5%87%BB%E6%9D%80%E6%95%8C%E4%BA%BA%E5%BE%97%E5%88%86.png"/></p><h4>解决办法</h4><p>在<code>AShooterCharacter::Die(...)</code>方法中添加判断，根据Tag判断是否造成伤害的物体为Missile</p><pre><code class="language-cpp">//增加积分并通知死亡事件发生
if(DamageCauser-&gt;Tags.Contains(FName(&quot;Missile&quot;)))
</code></pre><p>如果传入的参数判定为导弹击杀，则将击杀分数乘2</p><pre><code class="language-cpp">KillerPlayerState-&gt;ScoreKill(VictimPlayerState, KillScore * 2); 
</code></pre><p>实现操控炮台击败敌方，当前玩家可以获得双倍积分</p><h2>UMG界面</h2><h3>界面操作</h3><ul><li><p>按X键呼出3D UI，镜头指向按钮，鼠标右键能够点击3D按钮</p></li><li><p>P或Esc键呼出Option菜单</p></li></ul><h3>功能一</h3><p>添加一个击杀时醒目UI(屏幕中上方，注意Anchor和Alignment)</p><h4>实现效果</h4><p>在玩家击杀一个敌方单位后，屏幕中上方显示击杀图标</p><p><img src="./src/%E5%87%BB%E6%9D%80%E5%9B%BE%E6%A0%87.png"/></p><h4>解决办法</h4><p>创建一个继承自UuserWidget的蓝图名为<code>BP_KillWidget</code>；</p><p>添加Image组件命名为<code>Kill_Image</code>；</p><p>设定锚点为<strong>正上方</strong>，并给Alignment的X、Y值都赋为<strong>0.5</strong>，保证其在锚点正上方中央位置</p><p><img src="./src/Kill_Image.png"/></p><p><img src="./src/Alignment.png"/></p><p><img src="./src/Kill_Image%E7%BC%96%E8%BE%91%E8%93%9D%E5%9B%BE.png"/></p><p>在<strong>ShooterHUD.h</strong>中声明蓝图类<code>KillWidgetClass</code></p><pre><code class="language-cpp">/** 击杀后客户端显示的Widget*/
TSubclassOf&lt;UUserWidget&gt; KillWidgetClass;
UUserWidget* KillWidget;
</code></pre><p>在<strong>ShooterHUD.cpp</strong>的构造函数中使用<code>ConstructorHelpers::FclassFinder</code>获取到蓝图BP_KillWidget</p><pre><code class="language-cpp">AShooterHUD::AShooterHUD(const FObjectInitializer&amp; ObjectInitializer) : Super(ObjectInitializer)
{
    ...
    //获取蓝图资源BP_KillWidget
    static ConstructorHelpers::FClassFinder&lt;UUserWidget&gt; KillWidgetCl(TEXT(&quot;WidgetBlueprint&#x27;/Game/Blueprints/UI/BP_KillWidget.BP_KillWidget_C&#x27;&quot;));
    if(KillWidgetCl.Succeeded())
    {
        KillWidgetClass = KillWidgetCl.Class;
    }
    ...
}
</code></pre><p>在击败敌人后，会调用<code>AShooterHUD::DrawRecentlyKilledPlayer()</code>方法，在其中进行保护判断，如果存在<code>KillWidget</code>实例则remove，如果不存在就生成实例，将其添加进ViewPort．</p><pre><code class="language-cpp">//创建KillWidget
if(KillWidget)
{
    KillWidget-&gt;RemoveFromParent();
    KillWidget = nullptr;
}
if(KillWidgetClass &amp;&amp; !KillWidget)
{
    if(AShooterPlayerController* ShooterPC = Cast&lt;AShooterPla yerController&gt;(PlayerOwner))
    {
        KillWidget = CreateWidget&lt;UUserWidget&gt;(ShooterPC,KillWidgetClass);
        if(KillWidget)
        {
            KillWidget-&gt;AddToViewport();
        }
    }
}
</code></pre><hr/><h3>功能二</h3><p>为击杀UI添加动画(Fadeln&amp;Out/缩放等均可)</p><h4>实现效果</h4><p>功能一中创建的UI在生成后能够FadeOut的效果后消失</p><p><img src="./src/FadeOut%E6%95%88%E6%9E%9C%E5%9B%BE.png"/></p><h4>解决办法</h4><p>在<code>BP_KLillWidget</code>蓝图中为<code>Kill_Image</code>创建Animation，命为&quot;FadeOut_Animation&quot;，添加2个关键帧，定义图片的Alpha值</p><table><thead><tr><th>时间（s）</th><th>Item</th></tr></thead><tbody><tr><td>0.00</td><td>Color.A = 1.0</td></tr><tr><td>2.00</td><td>Color.A = 0.0</td></tr></tbody></table><p>在Event Graph中设定逻辑播放动画，实现FadeOut的效果</p><p><img src="./src/FadeOut.png"/></p><hr/><h3>功能三</h3><p>左上角显示游戏帧数，选项菜单里增加一个选项，作为控制是否显示游戏帧数的开关 </p><h4>实现效果</h4><p>在Option选项中添加控制FPS显示的开关，开启后能够在屏幕左上角显示帧数；</p><p>选项的数据（包括FPS是否开启显示）会存储在磁盘；</p><p>不同客户端会根据自身选项进行显示与否．</p><p><img src="./src/FPS.png"/></p><p><img src="./src/FPS_Off.png"/></p><h4>解决办法</h4><p>在<strong>ShooterOptions.h</strong>中声明确定FPS开关的属性和方法</p><pre><code class="language-cpp">/** FPS显示选项*/
TSharedPtr&lt;FShooterMenuItem&gt; FPSOption; 

/** 是否开启FPS显示 */
uint8 bFPSOpt : 1;

/** FPS开关控制器*/
void ToggleFPS(TSharedPtr&lt;FShooterMenuItem&gt; MenuItem, int32 MultiOptionIndex);
</code></pre><p>在<code>FShooterOptions::Construct()</code>方法中，在OptionItem中添加一项FPSOption，将ToggleFPS方法绑定到<code>FOnOptionChanged</code>代理对象上，当选项被玩家更改后就会调用<code>SShooterMenuWidget::ChangeOption(int32 MoveBy)</code>中的<code>OnOptionChanged.ExecuteIfBound(...)</code>执行函数<code>ToggleFPS</code>．</p><pre><code class="language-cpp">FPSOption = MenuHelper::AddMenuOptionSP(OptionsItem, LOCTEXT(&quot;fps&quot;, &quot;FPS&quot;), OnOffList, this, &amp;FShooterOptions::ToggleFPS);
</code></pre><p>编写实际运行的<strong>ToggleFPS()</strong>函数，将<code>bFPSOpt</code>同步到该客户端的PlayerController的<code>bFPSEnabled</code>属性上。其间夹杂<code>bFPSOpt</code>、<code>FPSOption</code>的默认设置和Get、Set方法的调用不过多赘述．</p><pre><code class="language-cpp">void FShooterOptions::ToggleFPS(TSharedPtr&lt;FShooterMenuItem&gt; MenuItem, int32 MultiOptionIndex)
{
   bFPSOpt = MultiOptionIndex &gt; 0 ? true : false;
   APlayerController* BaseController = Cast&lt;APlayerController&gt;(UGameplayStatics::GetPlayerController(PlayerOwner-&gt;GetWorld(), GetOwnerUserIndex()));
    
   AShooterPlayerController* ShooterPlayerController = Cast&lt;AShooterPlayerController&gt;(UGameplayStatics::GetPlayerController(PlayerOwner-&gt;GetWorld(), GetOwnerUserIndex()));
    
   ensure(BaseController);
   if(BaseController)
   {
      if (ShooterPlayerController)
      {
         ShooterPlayerController-&gt;bFPSEnabled = bFPSOpt;
      }
   }
}
</code></pre><p>当点按 APPLY CHANGES 按钮后，将FPSOption当前index存入UShooterPersistentUser实例对象中，而后<code>SaveGameToSlot</code>中用于下次启动游戏加载先前设置．</p><p>创建继承自<code>UUserWidget</code>的<strong>BP_FPSWidget蓝图</strong>，创建富文本组件命名为<code>FPSRichText</code>，蓝图中计算帧数并赋值给<code>FPSRichText—Content</code>．</p><p><img src="./src/BP_FPSWidget.png"/></p><p>和功能二使用同样方法获取BP_FPSWidget蓝图资源，在<code>ShooterHUD.cpp</code>中创建实例，在DrawHUD()方法中根据当前<code>AShooterPlayerController::bFPSEnabled</code>正确生成Widget．</p><pre><code class="language-cpp">//显示FPS
if(!FPSWidget)
{
   FPSWidget = CreateWidget&lt;UUserWidget&gt;(MyPC,FPSWidgetClass);    
}
if(FPSWidget-&gt;IsInViewport() &amp;&amp; MyPC-&gt;bFPSEnabled == false)
{
   FPSWidget-&gt;RemoveFromViewport();
}
if(!FPSWidget-&gt;IsInViewport() &amp;&amp; MyPC-&gt;bFPSEnabled == true)
{
   FPSWidget-&gt;AddToViewport();
}
</code></pre><hr/><h3>功能四</h3><p>将局内的游戏菜单升级为3D UI (WidgetInteractionComponent) ，当菜单显示时，根据玩家位置始终显示在玩家侧前方，且可以正常点击</p><h4>实现效果</h4><p>按X键呼出3D UI，并且切换为TPP视角，镜头指向按钮，鼠标右键能够点击3D按钮</p><p>实现了3D UI，根据玩家位置始终显示在玩家侧前方，能够正常点击，通过点击3D UI能够在单机模式下播放人物动画</p><p><img src="./src/3DUI.png"/></p><p>点击进行播放动画</p><p><img src="./src/3DUI%E7%82%B9%E5%87%BB.png"/></p><p>（为了优化原项目TPP视角，将PlayerPawn的各个组件置为新的层级关系，相机组件上添加一个 SpringArm 组件）</p><p><img src="./src/PlayerPawn%E7%BB%84%E4%BB%B6%E5%B1%82%E7%BA%A7.png"/></p><p>（因为原项目UI界面都用HUD实现，时间不够将其全部重写，故实现如上所述的3D UI，未改变升级局内UI）</p><h4>解决办法</h4><ol><li><p>创建一个<strong>widget蓝图</strong>名为 <strong>DanceOption</strong></p><p>为其添加三个按钮并给每个按钮附着上文字（代表舞蹈的名称）</p></li></ol><p><img src="./src/DanceOption%E8%93%9D%E5%9B%BE.png"/></p><p>​		修改按钮的Appearance——Style——Normal、Hovered、Pressed的属性，实现部		分透明的UI控件，更加美观</p><p><img src="./src/%E6%8C%89%E9%92%AE%E6%A0%B7%E5%BC%8F.png"/></p><p>​		为按钮添加点击事件</p><ol start="2"><li><p>为PlayerPawn添加一个<strong>Widget组件</strong>，Widget Class 选定为 <strong>DanceOption</strong> </p><p>调整其层级关系和相对坐标旋转，置于人物侧前方</p></li></ol><p><img src="./src/FPPDanceOption%E7%BB%84%E4%BB%B6.png"/></p><ol start="3"><li><p>TPPCamera下添加 <strong>widgetinteraction组件</strong>，设置交互距离</p><p>事件蓝图中使用<code>Press Pointer Key</code>节点用鼠标右键模拟左键的按下和释放</p><p><img src="./src/3DUMG%E4%BA%A4%E4%BA%92%E8%93%9D%E5%9B%BE.png"/></p><p>实现了角色按X键呼出3D UI且始终显示在玩家侧前方， 并且通过右键点击，进行舞蹈的播放</p></li></ol><hr/><h2>基本物理</h2><h3>功能一</h3><p>不同的地面有不同的摩擦力</p><h4>实现效果</h4><ol><li><p>场景内的floor_5_Glass的物理材质被重载为自定义的&quot;M_Glass&quot;</p><p>修改地图此处floor_5_Glass玻璃的物理材质</p></li></ol><p><img src="./src/%E4%BF%AE%E6%94%B9%E7%8E%BB%E7%92%83%E7%89%A9%E7%90%86%E6%9D%90%E8%B4%A8.png"/></p><ol start="2"><li><p>两个滑块在不同的物理材质表面下滑得到不同的物理效果</p><p>开始下落</p><p><img src="./src/%E5%BC%80%E5%A7%8B%E4%B8%8B%E8%90%BD.png"/></p><p>结束下落</p><p><img src="./src/%E7%BB%93%E6%9D%9F%E4%B8%8B%E8%90%BD.png"/></p></li></ol><h4>解决办法</h4><p>自定义的M_Glass的属性如下:</p><p><img src="./src/Glass%E7%89%A9%E7%90%86%E6%9D%90%E8%B4%A8.png"/></p><p>自定义的M_Grass的属性如下:</p><p><img src="./src/Grass%E7%89%A9%E7%90%86%E6%9D%90%E8%B4%A8.png"/></p><ol><li>设置场景中地板floor_5_Glass的物理材质为&quot;M_Glass&quot;</li></ol><p><img src="./src/%E7%8E%BB%E7%92%83%E7%A2%B0%E6%92%9E%E5%B1%9E%E6%80%A7.png"/></p><ol start="2"><li><p>模拟物理后</p><ul><li><p>左边草地附着M_grass物理材质，摩擦力很大，无法平稳下滑</p></li><li><p>右边草地附着M_glass物理材质，摩擦力为0，能够下滑且速度很快</p></li></ul></li></ol><h3>功能二</h3><p>​	步枪子弹击中垃圾桶，可以把垃圾桶打飞</p><h4>实现效果</h4><p>步枪子弹射击垃圾桶，垃圾桶根据不同的受击位置和方向，对应产生被击打的物理效果</p><p>击中效果能够多端同步</p><p><img src="./src/%E5%B0%84%E5%87%BB%E5%9E%83%E5%9C%BE%E6%A1%B6.png"/></p><h4>解决办法</h4><p>设置垃圾桶物体的一些基本要素</p><ul><li>给垃圾桶的静态网格体添加简单碰撞</li><li>设置场景中的实例为&quot;可移动的&quot;</li><li>勾选&quot;物理——模拟物理&quot;；</li><li>质量、线性阻尼、角阻尼调整参数</li><li>为场景中的每个垃圾桶实例添加一个Tag：&quot;Trash&quot;</li></ul><p>设置组播方法<code>ProcessTrash()</code>，处理垃圾桶被子弹击中的效果</p><pre><code class="language-cpp">/** 对垃圾桶做出子弹碰撞反应 */
UFUNCTION(UnReliable,NetMulticast)
void ProcessTrash(const FHitResult&amp; Impact, const FVector&amp; ShootDir);
</code></pre><pre><code class="language-cpp">void AShooterWeapon_Instant::ProcessTrash(const FHitResult&amp; Impact,const FVector&amp; ShootDir)
{
    Impact.GetComponent()-&gt;AddImpulseAtLocation(ShootDir * 5000.0f, Impact.ImpactPoint);
}
</code></pre><p><code>AShooterWeapon_Instant::ProcessInstantHit_Confirmed(...)</code>函数处理子弹射击产生的效果，在其中根据射线返回值判断击中物体的Tag是否包含&quot;Trash&quot;，如果包含则将 HitResult引用和传递方向 ShootDir 传递进方法，并执行</p><pre><code class="language-cpp">void AShooterWeapon_Instant::ProcessInstantHit_Confirmed(const FHitResult&amp; Impact, const FVector&amp; Origin, const FVector&amp; ShootDir, int32 RandomSeed, float ReticleSpread)
{
    ...
    //判断是否击中的为垃圾桶，处理垃圾桶受击反馈
    if(Impact.bBlockingHit)
    {
        if(Impact.GetActor()-&gt;Tags.Contains(TEXT(&quot;Trash&quot;)) 
           &amp;&amp; Impact.GetActor()-&gt;IsRootComponentMovable())
        {
            ProcessTrash(Impact, ShootDir);
        }
    }
    ...
}
</code></pre><hr/><h3>功能三</h3><p>发射器发射的炮弹，呈抛物线飞行，碰到障碍可以反弹，碰到敌人或者倒计时结束则爆炸</p><h4>实现效果</h4><p>角色的炮弹武器，子弹实例能够呈抛物线飞行，倒计时结束时发生爆炸</p><p><img src="./src/%E7%82%B8%E5%BC%B9%E6%8A%9B%E7%89%A9%E7%BA%BF.png"/></p><p><img src="./src/%E7%82%B8%E5%BC%B9%E5%BC%B9%E5%B0%84.png"/></p><h4>解决办法</h4><p>发射器炮弹蓝图继承 AShooterProjectile 类，在其构造函数中修改属性和调参：启用弹力、设置弹性和设置重力</p><pre><code class="language-cpp">AShooterProjectile::AShooterProjectile(const FObjectInitializer&amp; ObjectInitializer) : Super(ObjectInitializer)
{
    ...
    MovementComp-&gt;bShouldBounce = true;
    MovementComp-&gt;Bounciness = 0.5f;
    MovementComp-&gt;ProjectileGravityScale = 0.5f;
    ...
}
</code></pre><p>实现炮弹呈抛物线状发射，并可以在障碍物间反弹，倒计时结束爆炸</p><hr/><h3>功能四</h3><p>角色面对墙壁时可以施展蹬墙二段跳，不用表现出蹬墙的动画，只需要满足面对墙壁足够近才能施展这个条件</p><h4>实现效果</h4><p>玩家能够在贴近墙体时，能够施展二段跳，且第二跳高度更高</p><p><img src="./src/%E4%BA%8C%E6%AE%B5%E8%B7%B3.png"/></p><h4>解决办法</h4><p>玩家类 AShooterCharacter 继承自 ACharacter类，ACharacter类中存在 JumpMaxCount 属性，表示最大跳跃次数</p><p>在AShooterCharacter类构造函数中将 <code>JumpMaxCount </code>置为2，使角色能够跳跃2次；<code>bCanDoubleJump</code>用来判断是否可以进行二段跳</p><pre><code class="language-cpp">/** 是否能进行二段跳 */
UPROPERTY(VisibleDefaultsOnly, Category = Pawn)
bool bCanDoubleJump;

AShooterCharacter::AShooterCharacter(const FObjectInitializer&amp; ObjectInitializer)
    : Super(ObjectInitializer.SetDefaultSubobjectClass&lt;UShooterCharacterMovement&gt;(ACharacter::CharacterMovementComponentName))
{
     ...
    bCanDoubleJump = false;
    JumpMaxCount = 2;
}
</code></pre><p>为场景中的墙体碰撞体积设置Tag为&quot;Wall&quot;</p><p>定义<code>OnHit</code>函数，将其绑定在多播委托变量OnComponentHit上，根据Tag判断角色的胶囊体是否碰撞了墙体,如果碰撞墙体并且现在进行了第一次跳跃，<code>bCanDoubleJump = true</code>，角色可以二段跳</p><pre><code class="language-cpp">/*当角色碰撞物体时会调用的函数。*/
    UFUNCTION()
    void OnHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComponent, FVector NormalImpulse, const FHitResult&amp; Hit);

void AShooterCharacter::BeginPlay()
{
    Super::BeginPlay();

    GetCapsuleComponent()-&gt;SetNotifyRigidBodyCollision(true);
    GetCapsuleComponent()-&gt;GetBodyInstance()-&gt;bNotifyRigidBodyCollision = true;
    GetCapsuleComponent()-&gt; OnComponentHit.AddDynamic(this,&amp;AShooterCharacter::OnHit);
}

void AShooterCharacter::OnHit(UPrimitiveComponent* HitComponent, AActor* OtherActor,
    UPrimitiveComponent* OtherComponent, FVector NormalImpulse, const FHitResult&amp; Hit)
{
    if(JumpCurrentCount == 1 &amp;&amp; OtherActor-&gt;Tags.Contains(&quot;Wall&quot;))
    {
        bCanDoubleJump = true;
    }
}
</code></pre><p>在<code>OnStartJump()</code>和<code>OnStopJump()</code>方法中定义二段跳的触发条件，并且在第二跳发生时将Z轴速度提高，停止跳跃时将<code>JumpZVelocity</code>重置为720.0f</p><pre><code class="language-cpp">void AShooterCharacter::OnStartJump()
{
    AShooterPlayerController* MyPC = Cast&lt;AShooterPlayerController&gt;(Controller);
    if (MyPC &amp;&amp; MyPC-&gt;IsGameInputAllowed())
    {
        if(JumpCurrentCount == 0)   bPressedJump = true;
        else if(JumpCurrentCount == 1 &amp;&amp; bCanDoubleJump)
        {
            GetCharacterMovement()-&gt;JumpZVelocity = 1000.0f;
            bPressedJump = true;
        }
    }
}

void AShooterCharacter::OnStopJump()
{
    bPressedJump = false;
    StopJumping();
    if(JumpCurrentCount == 2)
    {
        bCanDoubleJump = false;
        GetCharacterMovement()-&gt;JumpZVelocity = 720.0f;
    }
}
</code></pre><p>实现蹬墙二段跳的效果，并且第二条速度更大，使角色能跳上场景中大部分墙体。</p><hr/><h3>功能五</h3><p>步枪子弹可以穿过一定厚度的墙，伤害随穿过障碍的厚度递减</p><h4>实现效果</h4><p>子弹可以穿墙打击敌人，子弹穿透墙体的伤害会根据在墙体中的移动距离进行衰减</p><p>并且在墙体位置仍旧存留弹孔、击中特效等效果</p><p><img src="./src/%E5%AD%90%E5%BC%B9%E7%A9%BF%E5%A2%99%E5%87%BB%E6%9D%80.png"/></p><p><img src="F:%5C2021-2023%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E8%B5%84%E6%BA%90%5C2021%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E9%AB%98%E6%A0%A1%E5%85%AC%E5%BC%80%E8%AF%BE%5C%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A%5CFinished_%E5%9F%BA%E6%9C%AC%E7%89%A9%E7%90%86-11%E6%9C%887%E6%97%A5%5Csrc%5C%E5%AD%90%E5%BC%B9%E4%BC%A4%E5%AE%B3%E8%A1%B0%E5%87%8F.png"/></p><h4>解决办法</h4><p>在 ShooterWeapon_Instant.h 中声明需要的属性和方法</p><pre><code class="language-cpp">class AShooterWeapon_Instant : public AShooterWeapon
{
    ...
protected:
    /** 子弹穿过墙体递减后的伤害值*/
    UPROPERTY(Replicated)
    int32 AfterDecreaseDamage;

    /** 穿墙是否进行伤害递减*/
    UPROPERTY(Replicated)
    bool bDecreaseDamage;

    /** 处理伤害递减
     * @return 递减后的值
     */
    void DamageDecrease(float CrossLength);
    
    /*判断墙后是否存在Pawn，有的话返回被击中Pawn的HitResult，没有的话返回击中物体*/
FHitResult HavePawnBackWall(const FHitResult&amp; Impact, const FVector&amp; Start, const FVector&amp; End, const FVector&amp; ShootDir);
    ...
}
</code></pre><p>定义<code>FHitResult HavePawnBackWall(...)</code>函数,用于判断子弹是否穿过墙体击中了敌人。</p><ol><li><p>从玩家枪口方向<strong>发射一条射线</strong>，定义碰撞通道为OverLap（为了确保Overlap射线检测正确，射线忽略了地图中一些体积，比如<code>AudioTrigger_Atrium</code>），防止碰到第一个实体停止检测</p></li><li><p>根据射线获得的<strong>HitResult数组</strong>，(纯OverLap通道会多次重叠自身的组件和本身)遍历数组先获得需要排除的自身个数SelfNum</p></li><li><p>根据标签判断下一个重叠的是否是墙体，如果是则继续判断下一个重叠的是否为Pawn</p></li><li><p>如果为真则从击中pawn的位置反向发射射线</p></li><li><p>多个Hit结果中可以提取出来穿透墙体的前后两点：击中墙体的位置、反向射线击中墙体的位置，做差，得出<code>CrossLength</code>为穿过的长度</p><p>（图中为Debug出穿透的墙体的前后两点，用两个黄点表示出来）</p></li></ol><p><img src="./src/%E7%A9%BF%E9%80%8F%E5%A2%99%E4%BD%93%E7%9A%84%E4%B8%A4%E4%B8%AA%E7%82%B9.png"/></p><p>使用公式 $AfterDecreaseDamage = HitDamage - CrossLength / 10.0f$ </p><p>将伤害衰减后存入<code>AfterDecreaseDamage</code>，为负则不行进伤害判定</p><pre><code class="language-cpp">FHitResult AShooterWeapon_Instant::HavePawnBackWall(const FHitResult&amp; Impact, const FVector&amp; Start, const FVector&amp; End, const FVector&amp; ShootDir)
{
    TArray&lt;FHitResult&gt; Hits;
    //Trace遍历子弹路径中穿过的物体
    UKismetSystemLibrary::LineTraceMulti(
GetWorld(),Start,End,UEngineTypes::ConvertToTraceType(ECC_GameTraceChannel4),true,ActorsToIgnore,EDrawDebugTrace::None,Hits,true,FLinearColor::Blue,FLinearColor::Red,20.0f
   );
    int SelfNum = 0;
    //检测到几个自己，确定SelfNum值
    for(int i=0;i&lt;Hits.Num();i++)
    {
        //前序碰到的都是自己
        if(!Hits[i].GetActor()-&gt;GetName().Compare(this-&gt;GetPawnOwner()-&gt;GetName()))
        {
            SelfNum++;
        }
        else
            break;
    }
    //检测是否直接击中墙体，若无直接返回原Hit结果
    if(Hits.Num() &gt;= SelfNum-1)
        if(!Hits[SelfNum].GetActor()-&gt;Tags.Contains(TEXT(&quot;Wall&quot;)))
        {
            return Impact;
        }
    if(Hits.Num() &gt;= SelfNum)
        if(Hits[SelfNum + 1].GetActor()-&gt;Tags.Contains(TEXT(&quot;Player&quot;)))
        {
            //UE_LOG(LogTemp,Warning,TEXT(&quot;Get Actor!!!&quot;));
            FHitResult Hit; 
            //从击中敌人Pawn的位置向出发点发射Trace，  HitTrace即可
            GetWorld()-&gt;LineTraceSingleByChannel(Hit, Hits[SelfNum+1].Location, Start, COLLISION_WEAPON);
            //做差，从而得出子弹穿过墙体的长度
        DamageDecrease(FVector::Distance(Hits[SelfNum].Location,Hit.Location));
            bDecreaseDamage = true;
            return Hits[SelfNum + 1];
        }
    if(AfterDecreaseDamage &lt;= 0.0f)
    {
        bDecreaseDamage = false;
        return Impact;
    }
    return Impact;
}
</code></pre><p><code>AShooterWeapon_Instant::DealDamage</code>中判断是否进行伤害递减，进行伤害最终传入</p><pre><code class="language-cpp">void AShooterWeapon_Instant::DealDamage(const FHitResult&amp; Impact, const FVector&amp; ShootDir)
{
   FPointDamageEvent PointDmg;
   PointDmg.DamageTypeClass = InstantConfig.DamageType;
   PointDmg.HitInfo = Impact;
   PointDmg.ShotDirection = ShootDir;
    
   if(InstantConfig.bDecreaseDamage)
      PointDmg.Damage = InstantConfig.AfterDecreaseDamage;
   else
      PointDmg.Damage = InstantConfig.HitDamage;

   //处理伤害
   Impact.GetActor()-&gt;TakeDamage(PointDmg.Damage, PointDmg, MyPawn-&gt;Controller, this);
}
</code></pre><p>在<code>AShooterWeapon_Instant::FireWeapon()</code>中，判断第一次射线和<code>HavePawnBackWall()</code>的返回值是否为一个Hit结果</p><ul><li>如果两个Hit值相等，则没发射穿墙事件</li><li>否则发生穿墙事件，在原Impact击中位置生成打击效果</li></ul><pre><code class="language-cpp">const FHitResult Impact = WeaponTrace(StartTrace, EndTrace);
/*查询墙后是否有pawn*/
FHitResult FinalImpact = HavePawnBackWall(Impact,StartTrace,EndTrace,ShootDir);

//墙面依旧留下弹痕
if(Impact.IsValidBlockingHit() &amp;&amp; FinalImpact.IsValidBlockingHit())
   if(Impact.GetActor()-&gt;GetName().Compare(FinalImpact.GetActor()-&gt;GetName()))
   {
      if (GetNetMode() != NM_DedicatedServer)
      {
         SpawnImpactEffects(Impact);
      }
   }
</code></pre><p>实现子弹穿墙打击敌人，子弹穿透墙体的伤害能够根据在墙体中移动的距离进行衰减，墙上仍产生弹孔</p><hr/><h2>骨骼动画</h2><h3>操作说明</h3><p>1、Ctrl+1/2/3播放三种不同的舞蹈动画</p><p>2、X键呼出3D UI，瞄准按钮并点按鼠标右键，能够在单机模式下播放人物动画</p><p>3、按Z能够使角色蹲下</p><h3>功能一</h3><p>按键（ctrl+数字键）可以触发角色不同的表演动作</p><h4>实现效果</h4><p>Ctrl+1/2/3播放三种不同的舞蹈动画，并自动切换第三人称</p><p><img src="./src/%E8%B7%B3%E8%88%9E1.png"/></p><p>X键呼出3D UI，瞄准按钮并点按鼠标右键，能够在单机模式下播放人物动画</p><p><img src="./src/3DUI.png"/></p><h4>解决办法</h4><h5>修复原项目bug</h5><p>先修复了原项目出现的bug，第三人称可视第一人称手臂mesh、无法看到第三人称枪械</p><p>AShooterCharacter::UpdatePawnMeshes()中添加逻辑判定，在不同模式下，隐藏不需要的人物和枪械mesh</p><pre><code class="language-cpp">void AShooterCharacter::UpdatePawnMeshes()
{
    bool const bFirstPerson = IsFirstPerson();

    //TPP不需要看见人物mesh和枪械mesh
...
    if( this-&gt;IsLocallyControlled() == true )
    {
        //切换武器可见性
        if(Inventory.Num()&gt;=2)
        {
            for (int32 i = 0; i &lt; Inventory.Num(); i++)
            {
                if(Inventory[i])
                {
                    Inventory[i]-&gt;Mesh1P-&gt;SetOwnerNoSee(!bFirstPerson);
                    Inventory[i]-&gt;Mesh3P-&gt;SetOwnerNoSee(bFirstPerson);
                }
            }
        }
    }
...
}
</code></pre><p>又通过添加SprinArm和调节一下组件层级关系，修复了第三人称视角怪异的bug</p><h5>动画素材格式转换</h5><p>使用Mixamo_Converter软件，获取体重提供的角色3D模型，将其导入到Mixamo网站</p><p>选择3种舞蹈动画进行下载，再使用Mixamo_Converter软件将下载的fbx准换为UE4可以使用的格式</p><p>将转换好后的动画素材导入到UE4中，为官方小白人模型的动画</p><p><img src="./src/%E5%B0%8F%E7%99%BD%E4%BA%BA%E5%8A%A8%E7%94%BB.png"/></p><h5>骨骼重定向</h5><p>重定向原项目人物骨骼，对比两个骨骼位置，全部手动添加并调试</p><p>(花费了大量时间😭，不一一列举)</p><p><img src="./src/%E9%AA%A8%E9%AA%BC%E9%87%8D%E5%AE%9A%E5%90%91.png"/></p><p>再将骨骼节点的 Translation Retarget 选项慢慢调试：为动画或骨骼</p><p><img src="./src/Translation_Retarget.png"/></p><p>经过漫长的调参，尽量保证重定向后骨骼动画不至于拉伸严重</p><p>最后终于到了重定向骨骼的一步</p><p><img src="./src/%E9%87%8D%E5%AE%9A%E5%90%91%E6%93%8D%E4%BD%9C.png"/></p><p>得到相对较好的动画资源</p><p>将动画资源转为Montage，并且Slot设置为Full Body，并且改为根骨骼移动(防止mesh和collision不在一个位置)</p><h5>设置输入、播放动画</h5><p>cpp中使蓝图能够调用<code>TogglePerspective()</code>，从而调节TPP和FPP视角；</p><pre><code class="language-cpp">UFUNCTION(BlueprintCallable)
void TogglePerspective();

UPROPERTY(BlueprintReadWrite)
bool IsFPP;
</code></pre><p>在人物蓝图中设置输入并播放动画</p><p>输入事件在Dance中播放Montage，并且在播放中禁止任何输入(防止出现边跳舞边开枪的bug)delay相应的跳舞时间后启用输入操作</p><p>整体蓝图如下所示</p><p><img src="./src/%E4%BA%BA%E7%89%A9Dance%E8%93%9D%E5%9B%BE.png"/></p><p>Dance方法实现如下，设置必要的状态参数，并且在播放动画时自动切换第三人称</p><p><img src="./src/Dance%E6%96%B9%E6%B3%95.png"/></p><p>实现了按键播放人物动画，3D UI 启用动画在UMG中有详细解释</p><h3>功能二</h3><p>主角静止无输入5秒之后进入idle休闲动画，如耸肩、挠头等</p><h4>实现效果</h4><p>主角静止无输入5秒之后进入耸肩动画，同一无操作间隔内只进行一次，且不会与其他动画冲突</p><p><img src="./src/%E8%80%B8%E8%82%A9.png"/></p><h4>解决办法</h4><p>同功能一步骤制作蒙太奇<strong>耸肩动画</strong></p><p><img src="./src/%E8%80%B8%E8%82%A9%E5%8A%A8%E7%94%BB.png"/></p><p>Tcik计时，无数入进行5秒后，播放耸肩动画，有输入就停止播放</p><ul><li>跳舞时间内不会播放耸肩动画</li><li>下蹲时不会播放</li></ul><p><img src="./src/%E8%80%B8%E8%82%A9%E8%93%9D%E5%9B%BE.png"/></p><h3>功能三</h3><p>蹲姿及其配套的基础移动动作</p><h4>实现效果</h4><p>（动画重定向，手臂位置拉伸太大，功能都已实现，动画不适配的bug还未能修复😭）</p><p>人物按Z键能够实现蹲姿，同时减慢移动速度和减少胶囊体半高</p><p><img src="./src/%E8%B9%B2%E5%A7%BF.png"/></p><h4>解决办法</h4><p>人物移动组件Character movement 中勾选<strong>can crouch</strong> ✔️</p><p>修改<strong>移动速度</strong></p><p>（漫长的找素材过程，很遗憾骨骼重定向后人物手臂位置拉伸还是很严重）</p><p>通过蹲姿前进、后退、左移、右移等动画制作<strong>混合空间</strong>，设置横纵轴的参数和范围，横轴用来确定方向，纵轴对应人物移动速度</p><p><img src="./src/%E8%B9%B2%E5%A7%BF%E6%B7%B7%E5%90%88%E7%A9%BA%E9%97%B4%E8%BD%B4.png"/></p><p><img src="./src/%E6%B7%B7%E5%90%88%E7%A9%BA%E9%97%B4.png"/></p><p><strong>人物事件蓝图</strong>中设置<strong>按键Z进行下蹲</strong>，并相应的改变FPP相机高度和胶囊体半高</p><p><img src="./src/%E8%B9%B2%E5%A7%BF%E4%BA%8B%E4%BB%B6%E8%93%9D%E5%9B%BE.png"/></p><p>动画蓝图中新建<strong>Crouch状态机</strong>，Entry直连Crouch状态，设置对应的输入值</p><p><img src="./src/Crouch%E7%8A%B6%E6%80%81%E6%9C%BA.png"/></p><p>将原动画缓存为 SavedPose_OriginMovement ，Crouch状态机缓存为 SavedPose_Crouch ，使用波尔值Is Crouch和Blend Poses by Bool节点Blend动画</p><p>​	<img src="./src/%E6%B7%B7%E5%90%88%E8%B9%B2%E5%A7%BF%E5%8A%A8%E7%94%BB.png"/></p><p>实现按Z轴切换蹲姿和站立，不同方向的混合移动动画</p><h3>功能四</h3><p>停步动作，并优化其衔接表现</p><h4>实现效果</h4><p>添加跑动结束停步动画</p><h4>解决办法</h4><p>导入两只脚的停步动画</p><p>定义变量Is Right Foot 用于判断当前为哪只脚准备着地</p><p>在跑步动画关键帧中设置Notify事件RightFoot、LeftFoot</p><p><img src="./src/%E8%B7%91%E6%AD%A5%E9%80%9A%E7%9F%A5%E4%BA%8B%E4%BB%B6.png"/></p><p>在动画蓝图中用Notify事件给Is Right Foot 赋值</p><p><img src="./src/Notify.png"/></p><p>在状态机中添加一个状态,并设置相应的转换条件，当Speed&lt;100.0f时进入动画</p><p><img src="./src/%E8%B7%91%E5%8A%A8%E7%8A%B6%E6%80%81%E6%9C%BA.png"/></p><p>（导入的动画和跑步动画不适配，表现比较僵硬）</p><h3>功能五</h3><p>脚部的IK功能</p><h4>实现效果</h4><p>实现<strong>脚步IK功能</strong>，人物踏入不同高度的地面脚部会放置在不同高度（稍微有些内八）</p><p><img src="./src/%E8%84%9A%E6%AD%A5IK.png"/></p><p><img src="./src/%E5%89%8D%E8%A7%86%E5%9B%BE.png"/></p><p>并且脚面能够进行<strong>旋转，从而贴合地面</strong></p><p><img src="./src/%E8%84%9A%E6%AD%A5%E6%97%8B%E8%BD%AC.png"/></p><h4>解决办法</h4><p>在角色左右脚骨骼添加插槽名为&quot;<code>LeftFootSocket</code>&quot;、&quot;<code>RightFootSocket</code>&quot;，为了后续获得此点的坐标信息；</p><p><img src="./src/Socket.png"/></p><p>构造函数中确定部分定义变量的值</p><ul><li><code>Scale</code>：角色比例</li><li><code>Foot Offset</code>：脚部插槽位置和脚底位置的差，用于解决脚部骨骼的位置并不在脚后跟的下面导致的脚步下陷问题</li><li><code>Capsule Half Height</code>：初始胶囊体半高，用于后续修改胶囊体半长，防止角色上方空出碰撞部分</li></ul><p><img src="./src/IK%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0.png"/></p><p>通过射线检测，确定角色脚部需要抬高的偏移量，从而确定角色的脚实际应该摆放的位置。</p><p>角色蓝图中 PlayerPawn 中声明并定义<code>IK Foot Trace</code>方法，输入插槽名称和射线长度<code>TraceDistance</code>，世界坐标下向脚步下方插槽位置发射一条垂直射线，并返回<code>IKOffset</code>(脚部偏移量)</p><p><img src="./src/IK_Foot_Trace.png"/></p><p>角色Event Graph中， Event Tick 调用<code>IK Foot Trace</code>方法，将返回值Lerp后存入<code>IKoffsetRightFoot</code>、<code>IKoffsetLeftFoot</code>(插值左右脚实际该偏移的长度)中，使值平滑变动。 </p><p><img src="./src/%E8%8E%B7%E5%8F%96%E8%84%9A%E6%AD%A5Offset.png"/></p><p>获得了上述变量值，进而在动画蓝图中使用两个<strong>Two Bone IK</strong>节点，设置两个节点的<code>IKBone</code>、<code>Effector</code>、<code>Joint Target</code>，确保坐标空间为<code>Bone Space</code>,图中展示右脚部分的设置，左脚同理</p><p><img src="./src/Two_Bone_IK.png"/></p><p><img src="./src/Two_Bone_IK%E8%AE%BE%E7%BD%AE.png"/></p><p>在动画蓝图中定义<code>RightFootEffectorLocation</code>、<code>LeftFootEffectorLocation</code>，根据之前求出的左右脚偏移量，将其作为X值，赋值<code>RightFootEffectorLocation</code>、<code>LeftFootEffectorLocation</code>，根据左右脚的坐标系不同，确定两个变量的X值正负（因为根据的坐标系是基于左右脚的，脚部竖直向上位移的时候，变化的是Effector Location—X轴，并且左右脚还是相反的）</p><p><img src="./src/%E8%8E%B7%E5%BE%97Effector_Location.png"/></p><hr/><p><strong>解决角色被碰撞体挡住，不能进行脚步IK问题：</strong></p><p>在碰撞体宽度大的情况下，物体骨骼无法到达下一台阶的位置，也无法使用实现IK，通过<strong>把整体骨骼拉到下一级台阶，同时缩小胶囊体的半高</strong>解决</p><p>定义<code>Mesh Offset Z</code>变量，其值通过左右脚偏移量做差取绝对值负数获得，从而确定整体骨骼向下的偏移量，使用Transform(Modify) Bone节点将整体骨骼位置拉低，节点控制根骨骼在世界坐标的偏移。</p><p><img src="./src/Transform_Bone.png"/></p><p>拉低根骨骼的同时，人物上方会空出碰撞区域，同时根据<code>Mesh Offset Z</code>将碰撞体半场高修改解决问题</p><p><img src="./src/%E4%BF%AE%E6%94%B9%E5%8D%8A%E5%9C%BA%E9%AB%98.png"/></p><hr/><p><strong>解决脚部插槽高度与脚底高度不同，脚陷入问题：</strong></p><p>在脚底新建插槽，计算插槽与脚部插槽的高度差值<code>FootOffset</code>，在偏移量中加入此值，解决脚部有点陷入地面问题</p><hr/><p><strong>实现脚面贴合不同角度平面：</strong></p><p>在动画蓝图中添加两个<code>Transform（Modify）Bone</code>节点，用来更改左右脚的<code>Rotation</code>，将其分别关联在两只脚的骨骼上，并且在世界坐标下旋转</p><p><img src="./src/%E6%94%B9%E5%8F%98%E8%84%9A%E9%83%A8%E8%A7%92%E5%BA%A6%E8%93%9D%E5%9B%BE.png"/></p><p>根据射线HitResult的法向量信息，求解脚部该旋转的Rotator</p><p><img src="./src/%E5%9B%BE%E8%A7%A3%E8%84%9A%E9%83%A8%E6%97%8B%E8%BD%AC%E8%A7%92%E5%BA%A6.jpg"/></p><p><img src="./src/%E6%B1%82%E6%97%8B%E8%BD%AC%E8%A7%92.png"/></p><p>将值赋给<code>Transform（Modify）Bone</code>节点的Rotation，实现脚面贴合不同角度平面</p><p><img src="./src/%E8%84%9A%E9%83%A8%E6%97%8B%E8%BD%ACIK.png"/></p><p>整体动画蓝图</p><p><img src="./src/%E6%95%B4%E4%BD%93%E5%8A%A8%E7%94%BB%E8%93%9D%E5%9B%BE.png"/></p><hr/><h2>渲染基础</h2><h3>功能一</h3><p>使用标准材质，把场景地面修改为砖块或木板等均可</p><h4>实现效果</h4><p>将地图中一块地面的材质修改为橡木板材质</p><p><img src="./src/%E6%A9%A1%E6%9C%A8%E5%9C%B0%E6%9D%BF.png"/></p><h4>解决办法</h4><p>将此地板的材质—Element2替换为初学者内容包的M_Wood_Oak</p><p><img src="./src/%E6%9D%90%E8%B4%A8%E9%9D%A2%E6%9D%BF.png"/></p><hr/><h3>功能二</h3><p>使用标准材质，把枪械修改为金属</p><h4>实现效果</h4><p><img src="./src/%E9%87%91%E5%B1%9E%E6%AD%A6%E5%99%A8.png"/></p><h4>解决办法</h4><ul><li><p>将武器的主体材质替换为标准材质<code>M_Metal_Burnished_Steel</code>金属材质;</p></li><li><p>武器瞄准镜部分替换为标准材质<code>M_Metal_Steel</code>金属材质;</p></li></ul><p><img src="./src/%E6%AD%A6%E5%99%A8%E6%9D%90%E8%B4%A8.png"/></p><h3>功能三</h3><p>添加一种后处理效果</p><h4>实现效果</h4><p>自定义玻璃材质，修改静态网格体 MainHall_WallGrass_05 的材质，实现屏幕空间反射的后处理效果</p><p><img src="./src/%E7%8E%BB%E7%92%83%E6%95%88%E6%9E%9C.png"/></p><h4>解决办法</h4><p>新建材质Glass，设置参数基础颜色、metallic和粗糙度</p><p><img src="./src/Glass.png"/></p><p>生成实例Glass_Inst，赋值颜色为灰色</p><p><img src="./src/Glass_Ins.png"/></p><p>再生成实例Glass_Inst_Inst并赋值颜色Metallic为1.0，实现屏幕空间反射效果</p><p><img src="./src/Glass_Inst_Inst.png"/></p><p><img src="./src/%E5%B1%8F%E5%B9%95%E7%A9%BA%E9%97%B4%E5%8F%8D%E5%B0%84%E6%9D%90%E8%B4%A8%E7%90%83.png"/></p><h3>功能四</h3><p>使用材质编辑器，添加至少一种自定义材质，比如枪械上的UV动画</p><h4>实现效果</h4><ol><li>将两种枪械的瞄准镜部分添加了UV动画，使枪械表面产生流动的效果</li></ol><p><img src="./src/%E7%9E%84%E5%87%86%E9%95%9CUV%E5%8A%A8%E7%94%BB.png"/></p><ol start="2"><li>自定义半透明材质，物体穿过会将轮廓绘制并描绘出亮边</li></ol><p><img src="./src/%E8%87%AA%E5%AE%9A%E4%B9%89%E9%98%B2%E5%BE%A1%E6%9D%90%E8%B4%A8.png"/></p><p>将材质实例应用到Cube上囊括玩家出生点房间，子弹射线不会检测到其中的玩家，但是玩家能够正常穿过这道门，实现<strong>保护玩家在出生点不受外部子弹伤害</strong>的一种机制</p><p><img src="./src/%E5%B0%84%E5%87%BB%E9%98%B2%E5%BE%A1%E6%9D%90%E8%B4%A8.png"/></p><h4>解决办法</h4><ol><li>在武器材质蓝图中，给枪械瞄准镜部分纹理添加Panner节点，速度X设置为0.1，从而实现流动效果</li></ol><p><img src="./src/%E6%AD%A6%E5%99%A8%E6%9D%90%E8%B4%A8UV%E5%8A%A8%E7%94%BB.png"/></p><ol start="2"><li><p>新建自定义材质，命名为<strong>&quot;Transparency&quot;</strong></p><ul><li>混合模式 为 &quot;半透明&quot;</li><li>着色模型 为 &quot;无光照&quot;</li></ul><p>材质蓝图中创建各节点和参数并连接</p><p><img src="./src/%E9%98%B2%E5%BE%A1%E6%9D%90%E8%B4%A8%E8%93%9D%E5%9B%BE.png"/></p><p>生成材质实例，并在实例中将各个参数启用并赋值</p><ul><li>Depth：亮边宽度</li><li>Color：原色</li><li>Depth_Color：高亮颜色</li></ul><p><img src="./src/%E9%98%B2%E5%BE%A1%E6%9D%90%E8%B4%A8%E5%AE%9E%E4%BE%8B%E5%8F%82%E6%95%B0.png"/></p><p>实现如下效果</p><p><img src="./src/%E5%9C%86%E5%BC%A7%E5%8B%BE%E5%8B%92%E8%BD%AE%E5%BB%93.png"/></p><p>最后将材质添加到Cube上，Cube囊括玩家出生地，当有玩家穿过能够高亮轮廓，外面的子弹无法打进出生地，实现一种出生保护机制。</p></li></ol><h3>功能五</h3><p>结合游戏玩法丰富技能特效，比如开火、击中或爆炸特效等</p><h4>实现效果</h4><p>被击杀的玩家能够不是直接消失，而是先实现消融的材质特效再销毁</p><p><img src="./src/Pawn%E6%BA%B6%E8%A7%A3.png"/></p><h4>解决办法</h4><p>在人物材质的Blend Mode置为Masked，修改并赋值<code>EmissiveColor</code>、<code>OpacityMask</code>节点，将Value参数控制溶解程度，编写材质函数Sine_remapped、MF_Appearacne和材质蓝图，调参实现溶解效果</p><p><img src="./src/%E6%BA%B6%E8%A7%A3%E6%9D%90%E8%B4%A8%E8%93%9D%E5%9B%BE.png"/></p><p>Sine_remapped材质函数</p><p><img src="./src/Sine_remapped.png"/></p><p>MF_Appearacne材质函数</p><p><img src="./src/MF_Appearance%E8%93%9D%E5%9B%BE.png"/></p><p>基于此材质生成材质实例 HeroTPP_Inst，将Pawn的材质替换；</p><p>在ShooterCharacter.h中声明函数<code>LetPawnDissolve()</code>，使其控制溶解速度</p><pre><code class="language-cpp">public:
    UFUNCTION(BlueprintImplementableEvent)
        void LetPawnDissolve();
</code></pre><p>蓝图中重写<code>LetPawnDissolve</code>，延迟五秒后，使用TimeLine实现材质参数根据定义的时间线变化。</p><p><img src="./src/EventLetPawnDissolve.png"/></p><p>人物死亡时调用OnDeath()函数，所以在cpp <code>AShooterCharacter::onDeath()</code>函数中调用蓝图方法LetPawnDissolve()</p><pre><code class="language-cpp">void AShooterCharacter::OnDeath(...){
    ...
    LetPawnDissolve();
    ...
}
</code></pre><p>实现人物在死亡后，出现缓慢溶解的特效，再销毁物体</p><p><img src="./src/Pawn%E6%BA%B6%E8%A7%A32.png"/></p><hr/><h2>AI技术介绍</h2><h3>功能一</h3><p>通过设置NavMeshBoundsVolume生成地图的导航网格</p><h4>实现效果</h4><p>通过构建网格体边界体积（Navigation Mesh Bounds Volume），实现地图的导航网格</p><p><img src="./src/%E5%AF%BC%E8%88%AA%E7%BD%91%E6%A0%BC.png"/></p><h4>解决办法</h4><p>添加<strong>寻路网格体边界体积（Navigation Mesh Bounds Volume）</strong></p><p>解决寻路网格体在高度上绘制出现偏差问题，调整绘制寻路网格体的高度偏移将<code>RecastNavMesh-Common ———— Draw offset </code>设置为10.0f</p><h3>功能二</h3><p>基于生成的导航网格让角色从两点间自动寻路</p><h4>实现效果</h4><p>AI角色能够在两点间自动寻路，在到达一个目标点后延迟3秒</p><p><img src="./src/%E8%87%AA%E5%8A%A8%E5%AF%BB%E8%B7%AFA.png"/></p><p><img src="./src/%E8%87%AA%E5%8A%A8%E5%AF%BB%E8%B7%AFB.png"/></p><h4>解决办法</h4><p>在BotPawn的事件蓝图中添加MoveToA、MoveToB自定义事件，使用<code>AI Move To</code>节点，互相调用事件，实现AI角色从A坐标和B坐标基于导航网格来回移动寻路。</p><p><img src="./src/%E8%87%AA%E5%8A%A8%E5%AF%BB%E8%B7%AF%E8%93%9D%E5%9B%BE.png"/></p><h3>功能三</h3><p>在UE4中创建黑板，行为树以及行为树装饰器</p><h4>实现效果</h4><p>为AI角色创建黑板、行为树及装饰器等等</p><p>AI角色主要有三种行为：</p><ol><li>填充弹药：寻找最近子弹位置，移动到最近的子弹填充处进行子弹填充</li><li>发现敌人并攻击：如果视野内存在敌人，追逐敌人并攻击</li><li>未发现敌人/闲置状态：随机选定巡逻点并移动，实现随机巡逻</li></ol><p><img src="./src/%E8%A1%8C%E4%B8%BA%E6%A0%91%E6%80%BB%E8%A7%88.png"/></p><p>黑板关键帧</p><ul><li>Enemy<code>(Object)</code>：当前目标敌人，基类ShooterCharacter</li><li>NeedAmmo<code>(Bool)</code>：是否需要子弹，用于判定AI角色子弹是否充裕</li><li>Destination<code>(Vector)</code>：当前的目的地，可以是追逐玩家的位置、随机巡逻点或子弹填充地</li><li>SelfActor<code>(Object)</code>：自己</li><li>HasPlayerInSight<code>(Bool)</code>：在AI角色视线内是否存在敌人</li></ul><p><img src="./src/%E9%BB%91%E6%9D%BF%E6%80%BB%E8%A7%88.png"/></p><h4>解决办法</h4><p>后续功能将会相应部分的实现进行解释</p><h3>功能四</h3><p>使用行为树的基本节点（选择器、序列节点、平行节点等）以及角色移动组件实现NPC追逐玩家的任务</p><h4>实现效果</h4><p>AI角色在感知并发现敌人后，能够对发现目标进行追逐并攻击</p><p><img src="./src/%E8%BF%BD%E9%80%90%E7%8E%A9%E5%AE%B6.png"/></p><h4>解决办法</h4><p>由根连接一个Selector，其上挂载<code>BotSearchEnemyLOS</code>和<code>Shoot An Enemy</code>两个服务</p><p><img src="./src/%E8%A1%8C%E4%B8%BA%E6%A0%91%E6%A0%B9.png"/></p><ul><li><p>BotSearchEnemyLOS服务：间隔0.5s，调用ShooterAIController中的cpp方法，找到距离最近的Enemy并且给黑板键<code>Enemy</code>赋值，将其设置为当前目标</p></li><li><p>BotShooeEnemy服务：调用<code>AShooterAIController::ShootEnemy()</code>，根据黑板健<code>Enemy</code>、敌人是否存活、当前弹药值等条件判断是否能够进行射击，并且赋值<code>bCanShoot</code>变量，间隔0.5s发射子弹</p><pre><code class="language-cpp">void AShooterAIController::ShootEnemy()
{
    ...
   bool bCanShoot = false;
   AShooterCharacter* Enemy = GetEnemy();
   if ( Enemy &amp;&amp; ( Enemy-&gt;IsAlive() )&amp;&amp; (MyWeapon-&gt;GetCurrentAmmo() &gt; 0) &amp;&amp; ( MyWeapon-&gt;CanFire() == true ) )
   {
      if (LineOfSightTo(Enemy, MyBot-&gt;GetActorLocation()))
      {
         bCanShoot = true;
      }
   }
   if (bCanShoot)
   {
      MyBot-&gt;StartWeaponFire();
   }
   else
   {
      MyBot-&gt;StopWeaponFire();
   }
}
</code></pre></li></ul><p>如果黑板的键<code>Enemy</code>已设置并且AI感知到敌人在视野之内，说明<strong>发现敌人</strong>，将进入到攻击序列Attack Sequence</p><p>在Find Point Near Enemy 任务中找到最近的敌人附近的位置，更新黑板的<code>Destination</code>值，<strong>获得AI角色该到达的<u>目的地</u></strong>(敌人附近)</p><p>Move To Enemy 任务<strong>跟随</strong>并攻击玩家，直至玩家死亡。</p><p><img src="./src/%E5%90%91%E6%95%8C%E4%BA%BA%E7%A7%BB%E5%8A%A8.png"/></p><h3>功能五</h3><p>基于行为树和AI感知组件实现随机巡逻任务</p><h4>实现效果</h4><p>(原项目只要地图中存在玩家，就会自动寻路找到玩家并攻击)</p><p>AI角色在没有感知到敌人时，进行随机巡逻，当视线内出现敌人后才开始进行攻击和追逐行为</p><p><img src="./src/%E9%9A%8F%E6%9C%BA%E5%B7%A1%E9%80%BB.png"/></p><h4>解决办法</h4><p>行为树中添加新的序列用于随机巡逻，添加两个<strong>装饰器</strong>(继承于BT装饰器蓝图基础)</p><ol><li><strong>RandomDes装饰器</strong>：用于找寻随机点，让AI角色进行随即巡逻</li></ol><p>​	根据Actor位置，连接<code>GetRandomReachablePointInRadius</code>节点，将返回值赋给Destination黑板键后完成执行</p><p><img src="./src/RandomDes.png"/></p><ol start="2"><li><strong>FindPlayer装饰器</strong>：重写Perform Condition Check AI，将BotPawn中的<code>Is Find Player</code>赋值给黑板键<code>Is Find Player</code></li></ol><p><img src="./src/RandomDes.png"/></p><p>将FindPlayer装饰器添加进攻击敌人的选择器中，如果视线内不存在敌人则不会进行攻击序列</p><p>为玩家角色蓝图添加<strong>AI感知刺激源组件</strong></p><p>给AI角色添加<strong>AI感知组件</strong>：视觉感知器官，对参数进行修改，归属检测全部选中</p><p><img src="./src/AI%E6%84%9F%E7%9F%A5%E7%BB%84%E4%BB%B6.png"/></p><p>定义<code>On Target Perception Updated</code>，如果感知到敌方并且为玩家，则设置Is Find Player为true</p><p><img src="./src/OnTargetPerceptionUpdated.png"/></p><p>实现AI通过视觉发现目标后去追随目标并进入攻击序列</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[ShooterGame说明文档]]></title>
            <link>https://gai-zi.github.io/Website/blog/ShooterGame说明文档</link>
            <guid>ShooterGame说明文档</guid>
            <pubDate>Tue, 18 Jan 2022 10:10:41 GMT</pubDate>
            <description><![CDATA[项目源代码：gai-zi/ShooterGame: Aurora Studios (github.com)]]></description>
            <content:encoded><![CDATA[<p>:::info</p><p>项目源代码：<a href="https://github.com/gai-zi/ShooterGame">gai-zi/ShooterGame: Aurora Studios (github.com)</a></p><p>打包游戏链接：<a href="https://share.weiyun.com/Lxd5HSw1">https://share.weiyun.com/Lxd5HSw1</a></p><p>:::</p><p>:::tip</p><p>UE版本：4.26</p><p>“如需要进入编辑器或导出应用查看实现效果，请选择&#x27;Highrise&#x27;地图”</p><p>:::</p><h2>游戏模式</h2><h3>炮台<strong>使用说明</strong></h3><p> 1、玩家贴近炮台，准星对准炮台，按<strong>E键</strong>进入炮台，再按E键退出炮台继续操控原角色</p><p>2、<strong>旋转鼠标X轴</strong>，能够旋转炮台朝向方向</p><p>3、鼠标左键，发射<code>BP_Missile</code>导弹，遇到障碍物或玩家能够爆炸，产生范围伤害</p><p>4、使用炮台发射的导弹击杀玩家，能够获得双倍积分</p><p><img src="./src/%E7%82%AE%E5%8F%B0E.png"/></p><h3>功能一</h3><p>在场景中生成一个炮台</p><h4>实现效果</h4><p>创建&quot;BP_Turret&quot;蓝图继承自定义cpp类<code>ATurret</code>，置于场景中</p><p><img src="./src/%E5%9C%BA%E6%99%AF%E4%B8%AD%E7%82%AE%E5%8F%B0.png"/></p><p><img src="./src/%E7%82%AE%E5%8F%B0.png"/></p><h4>解决办法</h4><p>新建<strong>cpp类 ATurret</strong> 继承自 APawn</p><p>头文件声明必要的组件和属性，构造函数定义组件的属性</p><pre><code class="language-cpp">class SHOOTERGAME_API ATurret : public APawn
{
protected:
    UPROPERTY(EditAnywhere,Category=Component)
    UBoxComponent* BoxComponent;
    //最下层底座
    UPROPERTY(EditAnywhere,Category=Component)
    UStaticMeshComponent* Base;
    //可转底座
    UPROPERTY(EditAnywhere,Category=Component)
    UStaticMeshComponent* Base2;
    //发射器
    UPROPERTY(EditAnywhere,Category=Component)
    UStaticMeshComponent* Launcher;
    //相机组件
    UPROPERTY(EditAnywhere,Category=Component)
    UCameraComponent* OurCamera;
    //要生成的发射物蓝图
    TSubclassOf&lt;AShooterProjectile&gt; ProjectileClass;
}
</code></pre><p>BP_Turret蓝图继承此cpp类，将炮台的各个mesh、material赋值，填充新的组件，组件列表如下</p><p><img src="./src/%E7%82%AE%E5%8F%B0%E7%BB%84%E4%BB%B6%E5%88%97%E8%A1%A8.png"/></p><ul><li>Box Component：盒体碰撞体<ul><li>Base：炮台底部基座<ul><li>Base1：炮台支架，通过旋转此组件实现发射器左右旋转<ul><li>Launcher：发射器，从发射器内发射BP_Missile导弹</li><li>Our Camera：摄像机组件</li></ul></li></ul></li></ul></li></ul><h3>功能二</h3><p>炮台可以按照固定频率向固定方向发射炮弹</p><h4>实现效果</h4><p>进入炮台后，按鼠标左键能够发射导弹，<strong>间隔时间 1.5s</strong> ；</p><p><img src="./src/%E7%82%AE%E5%8F%B0%E5%8F%91%E5%B0%84.png"/></p><p><img src="./src/%E7%82%AE%E5%8F%B0%E5%8F%91%E5%B0%84%E7%89%A9%E7%88%86%E7%82%B8.png"/></p><p>自定义导弹状发射物<strong>BP_Missile</strong>蓝图，继承自 <code>AShooter Projectile</code>，导弹发射和运动能够实现多人同步</p><p><img src="./src/%E5%AF%BC%E5%BC%B9%E8%93%9D%E5%9B%BE%E7%BB%84%E4%BB%B6.png"/></p><p><img src="./src/%E7%AC%AC%E4%B8%89%E6%96%B9%E8%A7%86%E8%A7%92%E5%8F%91%E5%B0%84%E5%AF%BC%E5%BC%B9.png"/></p><h4>解决办法</h4><h4>导弹</h4><p>自定义蓝图 BP_Missile 继承自 Shooter Projectile </p><p>从网络资源中找到导弹的mesh，新建Static Mesh组件并添加成为BP_Missile的mesh</p><p><img src="./src/Missile_Mesh.png"/></p><p>定义Explpsion Template为ProjRocket_Explosion，添加爆炸粒子效果，当击中物体时产生爆炸</p><p><img src="./src/Missile_Effect.png"/></p><p>射线检测碰撞，发射一条从基坐标向运动方向的射线，如果触碰到就隐藏Mesh，再跟随根组件一起销毁，避免爆炸完后游戏世界还留有一个空壳炸弹的bug</p><p><img src="./src/Missile%E5%B0%84%E7%BA%BF%E6%A3%80%E6%B5%8B.png"/></p><h4>炮台Pawn控制发射</h4><p>Turret.h声明必要的属性和方法</p><pre><code class="language-cpp">//控制发射间隔参数
bool bCanFire = true;
float LastFireTime = 0.0f;
float FireRate = 1.5f;
//发射导弹
UFUNCTION()
void Fire();
</code></pre><p>设置鼠标左键按键绑定，绑定Fire()函数</p><pre><code class="language-cpp">PlayerInputComponent-&gt;BindAction(&quot;Fire&quot;,IE_Pressed,this,&amp;ATurret::Fire);
</code></pre><p>构造函数获取导弹蓝图BP_Missile</p><pre><code class="language-cpp">static ConstructorHelpers::FClassFinder&lt;AShooterProjectile&gt; ProjectileBP(TEXT(&quot;Blueprint&#x27;/Game/Blueprints/Weapons/BP_Missile.BP_Missile_C&#x27;&quot;));
if(ProjectileBP.Succeeded())
   ProjectileClass = ProjectileBP.Class;
</code></pre><p>Fire()函数内获取当前发射器旋转和坐标，来定义导弹出生位置的坐标和旋转；</p><p>如果条件允许，生成导弹</p><pre><code class="language-cpp">void ATurret::Fire()
{
   if(!bCanFire)  return;
   //获取炮台基座的世界坐标下的旋转
    ...//为各个组件的坐标相加，不过多赘述
   FRotator MissileWorldRotator = BaseWorldRotation + Base2WorldRotation;
   FVector MissileWorldLocation = BoxWorldLocation + BaseWorldLocation + Base2WorldLocation + LuncherWorldLocation;
   
   UWorld* World = GetWorld();   
   if(World)
   {
      FActorSpawnParameters SpawnParams;
      SpawnParams.Owner = this;
      SpawnParams.Instigator = GetInstigator();
      if(ProjectileClass)
      {
         AShooterProjectile* Proj= World-&gt;SpawnActor&lt;AShooterProjectile&gt;(ProjectileClass,MissileWorldLocation,MissileWorldRotator,SpawnParams);
      }
   }
   bCanFire = false;
   LastFireTime = 0.0f;
}
</code></pre><p>每帧计算当前时间间隔，若超过 1.5s 未发射导弹，将bCanFire置为true，每次发射后在Fire()方法中都会将bCanFire重置为false，重新计时。</p><pre><code class="language-cpp">void ATurret::Tick(float DeltaTime)
{
   Super::Tick(DeltaTime);
   
   if(!bCanFire &amp;&amp; LastFireTime &lt;= 1.5f)
   {
      LastFireTime += DeltaTime;
      if(LastFireTime &gt;= 1.5f) bCanFire = true;
   }
}
</code></pre><p>实现发射物按固定间隔1.5s发射导弹</p><h3>功能三</h3><p>炮弹可以击中角色并产生一定伤害</p><h4>实现效果</h4><p>导弹击中敌人产生爆炸效果，同时对敌人造成伤害，伤害值置为50，直接击败敌人</p><p><img src="./src/%E7%82%AE%E5%8F%B0%E5%87%BB%E8%B4%A5%E6%95%8C%E4%BA%BA.png"/></p><h4>解决办法</h4><p>通过基类 ShooterProjectile 方法，在发生碰撞后调用Explode()方法产生爆炸效果，并且调用<code>ApplyRadialDamage</code>方法造成伤害</p><pre><code class="language-cpp">UGameplayStatics::ApplyRadialDamage(this, WeaponConfig.ExplosionDamage, NudgedImpactLocation, WeaponConfig.ExplosionRadius, WeaponConfig.DamageType, TArray&lt;AActor*&gt;(), this, MyController.Get());
</code></pre><h3>功能四</h3><p>玩家可以让角色操控炮台调整左右方向，同时只能一个角色操控</p><h4>实现效果</h4><p>能够让玩家操控炮台并左右方向旋转发射器，同时只能有一个角色进入炮台</p><h4>解决办法</h4><h4>角色控制炮台</h4><p>ATurret类中定义<code>CurrentShooterCharacter</code>，用于存放当前控制自己的角色实例</p><pre><code class="language-cpp">//当前控制此炮台的角色
UPROPERTY(BlueprintReadWrite)
AShooterCharacter* CurrentShooterCharacter;
</code></pre><p>PlayerPawn蓝图中定义：</p><ul><li>PlayerPawn：当前角色的<code>AShooterCharacter</code>实例</li><li>PlayerPawnController：当前角色的控制器</li></ul><p>按E键，角色从当前相机位置向前发射一条射线，如果碰撞到了Turret，则可以控制该炮台，并且把这个炮台的<code>CurrentShooterCharacter</code>赋值为自身</p><p><img src="./src/E%E9%94%AE%E8%BF%9B%E5%85%A5%E7%82%AE%E5%8F%B0.png"/></p><p>Trace From Camera 方法中发射射线，并且检测是否碰撞的是炮台，将角色蓝图中的Turret赋值，并返回布尔值true</p><p><img src="./src/%E6%91%84%E5%83%8F%E6%9C%BA%E5%B0%84%E7%BA%BF.png"/></p><p>炮台中按E键会让控制器重新控制当前的人物角色<code>CurrentShooterCharacter</code></p><p><img src="./src/%E7%82%AE%E5%8F%B0%E9%87%8D%E6%96%B0%E6%93%8D%E6%8E%A7%E4%BA%BA%E7%89%A9.png"/></p><h4>实现炮台转向</h4><p>当前炮台拥有两个基座和一个发射器，需要调整左右方向，就需要更改 Base2 的Rotation Z值</p><p><img src="./src/%E6%97%8B%E8%BD%AC%E7%82%AE%E5%8F%B0.png"/></p><p>在Turret.h中声明TurnRight()方法，将其与鼠标X轴映射绑定，方法代码如下</p><pre><code class="language-cpp">void ATurret::TurnRight(float Value)
{
   //沿着Z轴旋转roll
   float Base2Yaw = Base2-&gt;GetRelativeRotation().Yaw;
   if(Value!=0.0f)
   {
      Base2-&gt;SetRelativeRotation(FRotator(0.0f,Base2Yaw+Value,0.0f));
   }
}
</code></pre><p>实现左右旋转炮台</p><h3>功能五</h3><p>玩家操控炮台击中敌方，导致死亡，玩家可以获得双倍积分</p><h4>实现效果</h4><p>枪械击杀敌人得分：2分</p><p><img src="./src/%E6%9E%AA%E6%A2%B0%E5%87%BB%E6%9D%80%E6%95%8C%E4%BA%BA%E5%BE%97%E5%88%86.png"/></p><p>炮台击杀敌人得分：4分</p><p><img src="./src/%E7%82%AE%E5%8F%B0%E5%87%BB%E6%9D%80%E6%95%8C%E4%BA%BA%E5%BE%97%E5%88%86.png"/></p><h4>解决办法</h4><p>在<code>AShooterCharacter::Die(...)</code>方法中添加判断，根据Tag判断是否造成伤害的物体为Missile</p><pre><code class="language-cpp">//增加积分并通知死亡事件发生
if(DamageCauser-&gt;Tags.Contains(FName(&quot;Missile&quot;)))
</code></pre><p>如果传入的参数判定为导弹击杀，则将击杀分数乘2</p><pre><code class="language-cpp">KillerPlayerState-&gt;ScoreKill(VictimPlayerState, KillScore * 2); 
</code></pre><p>实现操控炮台击败敌方，当前玩家可以获得双倍积分</p><h2>UMG界面</h2><h3>界面操作</h3><ul><li><p>按X键呼出3D UI，镜头指向按钮，鼠标右键能够点击3D按钮</p></li><li><p>P或Esc键呼出Option菜单</p></li></ul><h3>功能一</h3><p>添加一个击杀时醒目UI(屏幕中上方，注意Anchor和Alignment)</p><h4>实现效果</h4><p>在玩家击杀一个敌方单位后，屏幕中上方显示击杀图标</p><p><img src="./src/%E5%87%BB%E6%9D%80%E5%9B%BE%E6%A0%87.png"/></p><h4>解决办法</h4><p>创建一个继承自UuserWidget的蓝图名为<code>BP_KillWidget</code>；</p><p>添加Image组件命名为<code>Kill_Image</code>；</p><p>设定锚点为<strong>正上方</strong>，并给Alignment的X、Y值都赋为<strong>0.5</strong>，保证其在锚点正上方中央位置</p><p><img src="./src/Kill_Image.png"/></p><p><img src="./src/Alignment.png"/></p><p><img src="./src/Kill_Image%E7%BC%96%E8%BE%91%E8%93%9D%E5%9B%BE.png"/></p><p>在<strong>ShooterHUD.h</strong>中声明蓝图类<code>KillWidgetClass</code></p><pre><code class="language-cpp">/** 击杀后客户端显示的Widget*/
TSubclassOf&lt;UUserWidget&gt; KillWidgetClass;
UUserWidget* KillWidget;
</code></pre><p>在<strong>ShooterHUD.cpp</strong>的构造函数中使用<code>ConstructorHelpers::FclassFinder</code>获取到蓝图BP_KillWidget</p><pre><code class="language-cpp">AShooterHUD::AShooterHUD(const FObjectInitializer&amp; ObjectInitializer) : Super(ObjectInitializer)
{
    ...
    //获取蓝图资源BP_KillWidget
    static ConstructorHelpers::FClassFinder&lt;UUserWidget&gt; KillWidgetCl(TEXT(&quot;WidgetBlueprint&#x27;/Game/Blueprints/UI/BP_KillWidget.BP_KillWidget_C&#x27;&quot;));
    if(KillWidgetCl.Succeeded())
    {
        KillWidgetClass = KillWidgetCl.Class;
    }
    ...
}
</code></pre><p>在击败敌人后，会调用<code>AShooterHUD::DrawRecentlyKilledPlayer()</code>方法，在其中进行保护判断，如果存在<code>KillWidget</code>实例则remove，如果不存在就生成实例，将其添加进ViewPort．</p><pre><code class="language-cpp">//创建KillWidget
if(KillWidget)
{
    KillWidget-&gt;RemoveFromParent();
    KillWidget = nullptr;
}
if(KillWidgetClass &amp;&amp; !KillWidget)
{
    if(AShooterPlayerController* ShooterPC = Cast&lt;AShooterPla yerController&gt;(PlayerOwner))
    {
        KillWidget = CreateWidget&lt;UUserWidget&gt;(ShooterPC,KillWidgetClass);
        if(KillWidget)
        {
            KillWidget-&gt;AddToViewport();
        }
    }
}
</code></pre><hr/><h3>功能二</h3><p>为击杀UI添加动画(Fadeln&amp;Out/缩放等均可)</p><h4>实现效果</h4><p>功能一中创建的UI在生成后能够FadeOut的效果后消失</p><p><img src="./src/FadeOut%E6%95%88%E6%9E%9C%E5%9B%BE.png"/></p><h4>解决办法</h4><p>在<code>BP_KLillWidget</code>蓝图中为<code>Kill_Image</code>创建Animation，命为&quot;FadeOut_Animation&quot;，添加2个关键帧，定义图片的Alpha值</p><table><thead><tr><th>时间（s）</th><th>Item</th></tr></thead><tbody><tr><td>0.00</td><td>Color.A = 1.0</td></tr><tr><td>2.00</td><td>Color.A = 0.0</td></tr></tbody></table><p>在Event Graph中设定逻辑播放动画，实现FadeOut的效果</p><p><img src="./src/FadeOut.png"/></p><hr/><h3>功能三</h3><p>左上角显示游戏帧数，选项菜单里增加一个选项，作为控制是否显示游戏帧数的开关 </p><h4>实现效果</h4><p>在Option选项中添加控制FPS显示的开关，开启后能够在屏幕左上角显示帧数；</p><p>选项的数据（包括FPS是否开启显示）会存储在磁盘；</p><p>不同客户端会根据自身选项进行显示与否．</p><p><img src="./src/FPS.png"/></p><p><img src="./src/FPS_Off.png"/></p><h4>解决办法</h4><p>在<strong>ShooterOptions.h</strong>中声明确定FPS开关的属性和方法</p><pre><code class="language-cpp">/** FPS显示选项*/
TSharedPtr&lt;FShooterMenuItem&gt; FPSOption; 

/** 是否开启FPS显示 */
uint8 bFPSOpt : 1;

/** FPS开关控制器*/
void ToggleFPS(TSharedPtr&lt;FShooterMenuItem&gt; MenuItem, int32 MultiOptionIndex);
</code></pre><p>在<code>FShooterOptions::Construct()</code>方法中，在OptionItem中添加一项FPSOption，将ToggleFPS方法绑定到<code>FOnOptionChanged</code>代理对象上，当选项被玩家更改后就会调用<code>SShooterMenuWidget::ChangeOption(int32 MoveBy)</code>中的<code>OnOptionChanged.ExecuteIfBound(...)</code>执行函数<code>ToggleFPS</code>．</p><pre><code class="language-cpp">FPSOption = MenuHelper::AddMenuOptionSP(OptionsItem, LOCTEXT(&quot;fps&quot;, &quot;FPS&quot;), OnOffList, this, &amp;FShooterOptions::ToggleFPS);
</code></pre><p>编写实际运行的<strong>ToggleFPS()</strong>函数，将<code>bFPSOpt</code>同步到该客户端的PlayerController的<code>bFPSEnabled</code>属性上。其间夹杂<code>bFPSOpt</code>、<code>FPSOption</code>的默认设置和Get、Set方法的调用不过多赘述．</p><pre><code class="language-cpp">void FShooterOptions::ToggleFPS(TSharedPtr&lt;FShooterMenuItem&gt; MenuItem, int32 MultiOptionIndex)
{
   bFPSOpt = MultiOptionIndex &gt; 0 ? true : false;
   APlayerController* BaseController = Cast&lt;APlayerController&gt;(UGameplayStatics::GetPlayerController(PlayerOwner-&gt;GetWorld(), GetOwnerUserIndex()));
    
   AShooterPlayerController* ShooterPlayerController = Cast&lt;AShooterPlayerController&gt;(UGameplayStatics::GetPlayerController(PlayerOwner-&gt;GetWorld(), GetOwnerUserIndex()));
    
   ensure(BaseController);
   if(BaseController)
   {
      if (ShooterPlayerController)
      {
         ShooterPlayerController-&gt;bFPSEnabled = bFPSOpt;
      }
   }
}
</code></pre><p>当点按 APPLY CHANGES 按钮后，将FPSOption当前index存入UShooterPersistentUser实例对象中，而后<code>SaveGameToSlot</code>中用于下次启动游戏加载先前设置．</p><p>创建继承自<code>UUserWidget</code>的<strong>BP_FPSWidget蓝图</strong>，创建富文本组件命名为<code>FPSRichText</code>，蓝图中计算帧数并赋值给<code>FPSRichText—Content</code>．</p><p><img src="./src/BP_FPSWidget.png"/></p><p>和功能二使用同样方法获取BP_FPSWidget蓝图资源，在<code>ShooterHUD.cpp</code>中创建实例，在DrawHUD()方法中根据当前<code>AShooterPlayerController::bFPSEnabled</code>正确生成Widget．</p><pre><code class="language-cpp">//显示FPS
if(!FPSWidget)
{
   FPSWidget = CreateWidget&lt;UUserWidget&gt;(MyPC,FPSWidgetClass);    
}
if(FPSWidget-&gt;IsInViewport() &amp;&amp; MyPC-&gt;bFPSEnabled == false)
{
   FPSWidget-&gt;RemoveFromViewport();
}
if(!FPSWidget-&gt;IsInViewport() &amp;&amp; MyPC-&gt;bFPSEnabled == true)
{
   FPSWidget-&gt;AddToViewport();
}
</code></pre><hr/><h3>功能四</h3><p>将局内的游戏菜单升级为3D UI (WidgetInteractionComponent) ，当菜单显示时，根据玩家位置始终显示在玩家侧前方，且可以正常点击</p><h4>实现效果</h4><p>按X键呼出3D UI，并且切换为TPP视角，镜头指向按钮，鼠标右键能够点击3D按钮</p><p>实现了3D UI，根据玩家位置始终显示在玩家侧前方，能够正常点击，通过点击3D UI能够在单机模式下播放人物动画</p><p><img src="./src/3DUI.png"/></p><p>点击进行播放动画</p><p><img src="./src/3DUI%E7%82%B9%E5%87%BB.png"/></p><p>（为了优化原项目TPP视角，将PlayerPawn的各个组件置为新的层级关系，相机组件上添加一个 SpringArm 组件）</p><p><img src="./src/PlayerPawn%E7%BB%84%E4%BB%B6%E5%B1%82%E7%BA%A7.png"/></p><p>（因为原项目UI界面都用HUD实现，时间不够将其全部重写，故实现如上所述的3D UI，未改变升级局内UI）</p><h4>解决办法</h4><ol><li><p>创建一个<strong>widget蓝图</strong>名为 <strong>DanceOption</strong></p><p>为其添加三个按钮并给每个按钮附着上文字（代表舞蹈的名称）</p></li></ol><p><img src="./src/DanceOption%E8%93%9D%E5%9B%BE.png"/></p><p>​		修改按钮的Appearance——Style——Normal、Hovered、Pressed的属性，实现部		分透明的UI控件，更加美观</p><p><img src="./src/%E6%8C%89%E9%92%AE%E6%A0%B7%E5%BC%8F.png"/></p><p>​		为按钮添加点击事件</p><ol start="2"><li><p>为PlayerPawn添加一个<strong>Widget组件</strong>，Widget Class 选定为 <strong>DanceOption</strong> </p><p>调整其层级关系和相对坐标旋转，置于人物侧前方</p></li></ol><p><img src="./src/FPPDanceOption%E7%BB%84%E4%BB%B6.png"/></p><ol start="3"><li><p>TPPCamera下添加 <strong>widgetinteraction组件</strong>，设置交互距离</p><p>事件蓝图中使用<code>Press Pointer Key</code>节点用鼠标右键模拟左键的按下和释放</p><p><img src="./src/3DUMG%E4%BA%A4%E4%BA%92%E8%93%9D%E5%9B%BE.png"/></p><p>实现了角色按X键呼出3D UI且始终显示在玩家侧前方， 并且通过右键点击，进行舞蹈的播放</p></li></ol><hr/><h2>基本物理</h2><h3>功能一</h3><p>不同的地面有不同的摩擦力</p><h4>实现效果</h4><ol><li><p>场景内的floor_5_Glass的物理材质被重载为自定义的&quot;M_Glass&quot;</p><p>修改地图此处floor_5_Glass玻璃的物理材质</p></li></ol><p><img src="./src/%E4%BF%AE%E6%94%B9%E7%8E%BB%E7%92%83%E7%89%A9%E7%90%86%E6%9D%90%E8%B4%A8.png"/></p><ol start="2"><li><p>两个滑块在不同的物理材质表面下滑得到不同的物理效果</p><p>开始下落</p><p><img src="./src/%E5%BC%80%E5%A7%8B%E4%B8%8B%E8%90%BD.png"/></p><p>结束下落</p><p><img src="./src/%E7%BB%93%E6%9D%9F%E4%B8%8B%E8%90%BD.png"/></p></li></ol><h4>解决办法</h4><p>自定义的M_Glass的属性如下:</p><p><img src="./src/Glass%E7%89%A9%E7%90%86%E6%9D%90%E8%B4%A8.png"/></p><p>自定义的M_Grass的属性如下:</p><p><img src="./src/Grass%E7%89%A9%E7%90%86%E6%9D%90%E8%B4%A8.png"/></p><ol><li>设置场景中地板floor_5_Glass的物理材质为&quot;M_Glass&quot;</li></ol><p><img src="./src/%E7%8E%BB%E7%92%83%E7%A2%B0%E6%92%9E%E5%B1%9E%E6%80%A7.png"/></p><ol start="2"><li><p>模拟物理后</p><ul><li><p>左边草地附着M_grass物理材质，摩擦力很大，无法平稳下滑</p></li><li><p>右边草地附着M_glass物理材质，摩擦力为0，能够下滑且速度很快</p></li></ul></li></ol><h3>功能二</h3><p>​	步枪子弹击中垃圾桶，可以把垃圾桶打飞</p><h4>实现效果</h4><p>步枪子弹射击垃圾桶，垃圾桶根据不同的受击位置和方向，对应产生被击打的物理效果</p><p>击中效果能够多端同步</p><p><img src="./src/%E5%B0%84%E5%87%BB%E5%9E%83%E5%9C%BE%E6%A1%B6.png"/></p><h4>解决办法</h4><p>设置垃圾桶物体的一些基本要素</p><ul><li>给垃圾桶的静态网格体添加简单碰撞</li><li>设置场景中的实例为&quot;可移动的&quot;</li><li>勾选&quot;物理——模拟物理&quot;；</li><li>质量、线性阻尼、角阻尼调整参数</li><li>为场景中的每个垃圾桶实例添加一个Tag：&quot;Trash&quot;</li></ul><p>设置组播方法<code>ProcessTrash()</code>，处理垃圾桶被子弹击中的效果</p><pre><code class="language-cpp">/** 对垃圾桶做出子弹碰撞反应 */
UFUNCTION(UnReliable,NetMulticast)
void ProcessTrash(const FHitResult&amp; Impact, const FVector&amp; ShootDir);
</code></pre><pre><code class="language-cpp">void AShooterWeapon_Instant::ProcessTrash(const FHitResult&amp; Impact,const FVector&amp; ShootDir)
{
    Impact.GetComponent()-&gt;AddImpulseAtLocation(ShootDir * 5000.0f, Impact.ImpactPoint);
}
</code></pre><p><code>AShooterWeapon_Instant::ProcessInstantHit_Confirmed(...)</code>函数处理子弹射击产生的效果，在其中根据射线返回值判断击中物体的Tag是否包含&quot;Trash&quot;，如果包含则将 HitResult引用和传递方向 ShootDir 传递进方法，并执行</p><pre><code class="language-cpp">void AShooterWeapon_Instant::ProcessInstantHit_Confirmed(const FHitResult&amp; Impact, const FVector&amp; Origin, const FVector&amp; ShootDir, int32 RandomSeed, float ReticleSpread)
{
    ...
    //判断是否击中的为垃圾桶，处理垃圾桶受击反馈
    if(Impact.bBlockingHit)
    {
        if(Impact.GetActor()-&gt;Tags.Contains(TEXT(&quot;Trash&quot;)) 
           &amp;&amp; Impact.GetActor()-&gt;IsRootComponentMovable())
        {
            ProcessTrash(Impact, ShootDir);
        }
    }
    ...
}
</code></pre><hr/><h3>功能三</h3><p>发射器发射的炮弹，呈抛物线飞行，碰到障碍可以反弹，碰到敌人或者倒计时结束则爆炸</p><h4>实现效果</h4><p>角色的炮弹武器，子弹实例能够呈抛物线飞行，倒计时结束时发生爆炸</p><p><img src="./src/%E7%82%B8%E5%BC%B9%E6%8A%9B%E7%89%A9%E7%BA%BF.png"/></p><p><img src="./src/%E7%82%B8%E5%BC%B9%E5%BC%B9%E5%B0%84.png"/></p><h4>解决办法</h4><p>发射器炮弹蓝图继承 AShooterProjectile 类，在其构造函数中修改属性和调参：启用弹力、设置弹性和设置重力</p><pre><code class="language-cpp">AShooterProjectile::AShooterProjectile(const FObjectInitializer&amp; ObjectInitializer) : Super(ObjectInitializer)
{
    ...
    MovementComp-&gt;bShouldBounce = true;
    MovementComp-&gt;Bounciness = 0.5f;
    MovementComp-&gt;ProjectileGravityScale = 0.5f;
    ...
}
</code></pre><p>实现炮弹呈抛物线状发射，并可以在障碍物间反弹，倒计时结束爆炸</p><hr/><h3>功能四</h3><p>角色面对墙壁时可以施展蹬墙二段跳，不用表现出蹬墙的动画，只需要满足面对墙壁足够近才能施展这个条件</p><h4>实现效果</h4><p>玩家能够在贴近墙体时，能够施展二段跳，且第二跳高度更高</p><p><img src="./src/%E4%BA%8C%E6%AE%B5%E8%B7%B3.png"/></p><h4>解决办法</h4><p>玩家类 AShooterCharacter 继承自 ACharacter类，ACharacter类中存在 JumpMaxCount 属性，表示最大跳跃次数</p><p>在AShooterCharacter类构造函数中将 <code>JumpMaxCount </code>置为2，使角色能够跳跃2次；<code>bCanDoubleJump</code>用来判断是否可以进行二段跳</p><pre><code class="language-cpp">/** 是否能进行二段跳 */
UPROPERTY(VisibleDefaultsOnly, Category = Pawn)
bool bCanDoubleJump;

AShooterCharacter::AShooterCharacter(const FObjectInitializer&amp; ObjectInitializer)
    : Super(ObjectInitializer.SetDefaultSubobjectClass&lt;UShooterCharacterMovement&gt;(ACharacter::CharacterMovementComponentName))
{
     ...
    bCanDoubleJump = false;
    JumpMaxCount = 2;
}
</code></pre><p>为场景中的墙体碰撞体积设置Tag为&quot;Wall&quot;</p><p>定义<code>OnHit</code>函数，将其绑定在多播委托变量OnComponentHit上，根据Tag判断角色的胶囊体是否碰撞了墙体,如果碰撞墙体并且现在进行了第一次跳跃，<code>bCanDoubleJump = true</code>，角色可以二段跳</p><pre><code class="language-cpp">/*当角色碰撞物体时会调用的函数。*/
    UFUNCTION()
    void OnHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComponent, FVector NormalImpulse, const FHitResult&amp; Hit);

void AShooterCharacter::BeginPlay()
{
    Super::BeginPlay();

    GetCapsuleComponent()-&gt;SetNotifyRigidBodyCollision(true);
    GetCapsuleComponent()-&gt;GetBodyInstance()-&gt;bNotifyRigidBodyCollision = true;
    GetCapsuleComponent()-&gt; OnComponentHit.AddDynamic(this,&amp;AShooterCharacter::OnHit);
}

void AShooterCharacter::OnHit(UPrimitiveComponent* HitComponent, AActor* OtherActor,
    UPrimitiveComponent* OtherComponent, FVector NormalImpulse, const FHitResult&amp; Hit)
{
    if(JumpCurrentCount == 1 &amp;&amp; OtherActor-&gt;Tags.Contains(&quot;Wall&quot;))
    {
        bCanDoubleJump = true;
    }
}
</code></pre><p>在<code>OnStartJump()</code>和<code>OnStopJump()</code>方法中定义二段跳的触发条件，并且在第二跳发生时将Z轴速度提高，停止跳跃时将<code>JumpZVelocity</code>重置为720.0f</p><pre><code class="language-cpp">void AShooterCharacter::OnStartJump()
{
    AShooterPlayerController* MyPC = Cast&lt;AShooterPlayerController&gt;(Controller);
    if (MyPC &amp;&amp; MyPC-&gt;IsGameInputAllowed())
    {
        if(JumpCurrentCount == 0)   bPressedJump = true;
        else if(JumpCurrentCount == 1 &amp;&amp; bCanDoubleJump)
        {
            GetCharacterMovement()-&gt;JumpZVelocity = 1000.0f;
            bPressedJump = true;
        }
    }
}

void AShooterCharacter::OnStopJump()
{
    bPressedJump = false;
    StopJumping();
    if(JumpCurrentCount == 2)
    {
        bCanDoubleJump = false;
        GetCharacterMovement()-&gt;JumpZVelocity = 720.0f;
    }
}
</code></pre><p>实现蹬墙二段跳的效果，并且第二条速度更大，使角色能跳上场景中大部分墙体。</p><hr/><h3>功能五</h3><p>步枪子弹可以穿过一定厚度的墙，伤害随穿过障碍的厚度递减</p><h4>实现效果</h4><p>子弹可以穿墙打击敌人，子弹穿透墙体的伤害会根据在墙体中的移动距离进行衰减</p><p>并且在墙体位置仍旧存留弹孔、击中特效等效果</p><p><img src="./src/%E5%AD%90%E5%BC%B9%E7%A9%BF%E5%A2%99%E5%87%BB%E6%9D%80.png"/></p><p><img src="F:%5C2021-2023%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E8%B5%84%E6%BA%90%5C2021%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E9%AB%98%E6%A0%A1%E5%85%AC%E5%BC%80%E8%AF%BE%5C%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A%5CFinished_%E5%9F%BA%E6%9C%AC%E7%89%A9%E7%90%86-11%E6%9C%887%E6%97%A5%5Csrc%5C%E5%AD%90%E5%BC%B9%E4%BC%A4%E5%AE%B3%E8%A1%B0%E5%87%8F.png"/></p><h4>解决办法</h4><p>在 ShooterWeapon_Instant.h 中声明需要的属性和方法</p><pre><code class="language-cpp">class AShooterWeapon_Instant : public AShooterWeapon
{
    ...
protected:
    /** 子弹穿过墙体递减后的伤害值*/
    UPROPERTY(Replicated)
    int32 AfterDecreaseDamage;

    /** 穿墙是否进行伤害递减*/
    UPROPERTY(Replicated)
    bool bDecreaseDamage;

    /** 处理伤害递减
     * @return 递减后的值
     */
    void DamageDecrease(float CrossLength);
    
    /*判断墙后是否存在Pawn，有的话返回被击中Pawn的HitResult，没有的话返回击中物体*/
FHitResult HavePawnBackWall(const FHitResult&amp; Impact, const FVector&amp; Start, const FVector&amp; End, const FVector&amp; ShootDir);
    ...
}
</code></pre><p>定义<code>FHitResult HavePawnBackWall(...)</code>函数,用于判断子弹是否穿过墙体击中了敌人。</p><ol><li><p>从玩家枪口方向<strong>发射一条射线</strong>，定义碰撞通道为OverLap（为了确保Overlap射线检测正确，射线忽略了地图中一些体积，比如<code>AudioTrigger_Atrium</code>），防止碰到第一个实体停止检测</p></li><li><p>根据射线获得的<strong>HitResult数组</strong>，(纯OverLap通道会多次重叠自身的组件和本身)遍历数组先获得需要排除的自身个数SelfNum</p></li><li><p>根据标签判断下一个重叠的是否是墙体，如果是则继续判断下一个重叠的是否为Pawn</p></li><li><p>如果为真则从击中pawn的位置反向发射射线</p></li><li><p>多个Hit结果中可以提取出来穿透墙体的前后两点：击中墙体的位置、反向射线击中墙体的位置，做差，得出<code>CrossLength</code>为穿过的长度</p><p>（图中为Debug出穿透的墙体的前后两点，用两个黄点表示出来）</p></li></ol><p><img src="./src/%E7%A9%BF%E9%80%8F%E5%A2%99%E4%BD%93%E7%9A%84%E4%B8%A4%E4%B8%AA%E7%82%B9.png"/></p><p>使用公式 $AfterDecreaseDamage = HitDamage - CrossLength / 10.0f$ </p><p>将伤害衰减后存入<code>AfterDecreaseDamage</code>，为负则不行进伤害判定</p><pre><code class="language-cpp">FHitResult AShooterWeapon_Instant::HavePawnBackWall(const FHitResult&amp; Impact, const FVector&amp; Start, const FVector&amp; End, const FVector&amp; ShootDir)
{
    TArray&lt;FHitResult&gt; Hits;
    //Trace遍历子弹路径中穿过的物体
    UKismetSystemLibrary::LineTraceMulti(
GetWorld(),Start,End,UEngineTypes::ConvertToTraceType(ECC_GameTraceChannel4),true,ActorsToIgnore,EDrawDebugTrace::None,Hits,true,FLinearColor::Blue,FLinearColor::Red,20.0f
   );
    int SelfNum = 0;
    //检测到几个自己，确定SelfNum值
    for(int i=0;i&lt;Hits.Num();i++)
    {
        //前序碰到的都是自己
        if(!Hits[i].GetActor()-&gt;GetName().Compare(this-&gt;GetPawnOwner()-&gt;GetName()))
        {
            SelfNum++;
        }
        else
            break;
    }
    //检测是否直接击中墙体，若无直接返回原Hit结果
    if(Hits.Num() &gt;= SelfNum-1)
        if(!Hits[SelfNum].GetActor()-&gt;Tags.Contains(TEXT(&quot;Wall&quot;)))
        {
            return Impact;
        }
    if(Hits.Num() &gt;= SelfNum)
        if(Hits[SelfNum + 1].GetActor()-&gt;Tags.Contains(TEXT(&quot;Player&quot;)))
        {
            //UE_LOG(LogTemp,Warning,TEXT(&quot;Get Actor!!!&quot;));
            FHitResult Hit; 
            //从击中敌人Pawn的位置向出发点发射Trace，  HitTrace即可
            GetWorld()-&gt;LineTraceSingleByChannel(Hit, Hits[SelfNum+1].Location, Start, COLLISION_WEAPON);
            //做差，从而得出子弹穿过墙体的长度
        DamageDecrease(FVector::Distance(Hits[SelfNum].Location,Hit.Location));
            bDecreaseDamage = true;
            return Hits[SelfNum + 1];
        }
    if(AfterDecreaseDamage &lt;= 0.0f)
    {
        bDecreaseDamage = false;
        return Impact;
    }
    return Impact;
}
</code></pre><p><code>AShooterWeapon_Instant::DealDamage</code>中判断是否进行伤害递减，进行伤害最终传入</p><pre><code class="language-cpp">void AShooterWeapon_Instant::DealDamage(const FHitResult&amp; Impact, const FVector&amp; ShootDir)
{
   FPointDamageEvent PointDmg;
   PointDmg.DamageTypeClass = InstantConfig.DamageType;
   PointDmg.HitInfo = Impact;
   PointDmg.ShotDirection = ShootDir;
    
   if(InstantConfig.bDecreaseDamage)
      PointDmg.Damage = InstantConfig.AfterDecreaseDamage;
   else
      PointDmg.Damage = InstantConfig.HitDamage;

   //处理伤害
   Impact.GetActor()-&gt;TakeDamage(PointDmg.Damage, PointDmg, MyPawn-&gt;Controller, this);
}
</code></pre><p>在<code>AShooterWeapon_Instant::FireWeapon()</code>中，判断第一次射线和<code>HavePawnBackWall()</code>的返回值是否为一个Hit结果</p><ul><li>如果两个Hit值相等，则没发射穿墙事件</li><li>否则发生穿墙事件，在原Impact击中位置生成打击效果</li></ul><pre><code class="language-cpp">const FHitResult Impact = WeaponTrace(StartTrace, EndTrace);
/*查询墙后是否有pawn*/
FHitResult FinalImpact = HavePawnBackWall(Impact,StartTrace,EndTrace,ShootDir);

//墙面依旧留下弹痕
if(Impact.IsValidBlockingHit() &amp;&amp; FinalImpact.IsValidBlockingHit())
   if(Impact.GetActor()-&gt;GetName().Compare(FinalImpact.GetActor()-&gt;GetName()))
   {
      if (GetNetMode() != NM_DedicatedServer)
      {
         SpawnImpactEffects(Impact);
      }
   }
</code></pre><p>实现子弹穿墙打击敌人，子弹穿透墙体的伤害能够根据在墙体中移动的距离进行衰减，墙上仍产生弹孔</p><hr/><h2>骨骼动画</h2><h3>操作说明</h3><p>1、Ctrl+1/2/3播放三种不同的舞蹈动画</p><p>2、X键呼出3D UI，瞄准按钮并点按鼠标右键，能够在单机模式下播放人物动画</p><p>3、按Z能够使角色蹲下</p><h3>功能一</h3><p>按键（ctrl+数字键）可以触发角色不同的表演动作</p><h4>实现效果</h4><p>Ctrl+1/2/3播放三种不同的舞蹈动画，并自动切换第三人称</p><p><img src="./src/%E8%B7%B3%E8%88%9E1.png"/></p><p>X键呼出3D UI，瞄准按钮并点按鼠标右键，能够在单机模式下播放人物动画</p><p><img src="./src/3DUI.png"/></p><h4>解决办法</h4><h5>修复原项目bug</h5><p>先修复了原项目出现的bug，第三人称可视第一人称手臂mesh、无法看到第三人称枪械</p><p>AShooterCharacter::UpdatePawnMeshes()中添加逻辑判定，在不同模式下，隐藏不需要的人物和枪械mesh</p><pre><code class="language-cpp">void AShooterCharacter::UpdatePawnMeshes()
{
    bool const bFirstPerson = IsFirstPerson();

    //TPP不需要看见人物mesh和枪械mesh
...
    if( this-&gt;IsLocallyControlled() == true )
    {
        //切换武器可见性
        if(Inventory.Num()&gt;=2)
        {
            for (int32 i = 0; i &lt; Inventory.Num(); i++)
            {
                if(Inventory[i])
                {
                    Inventory[i]-&gt;Mesh1P-&gt;SetOwnerNoSee(!bFirstPerson);
                    Inventory[i]-&gt;Mesh3P-&gt;SetOwnerNoSee(bFirstPerson);
                }
            }
        }
    }
...
}
</code></pre><p>又通过添加SprinArm和调节一下组件层级关系，修复了第三人称视角怪异的bug</p><h5>动画素材格式转换</h5><p>使用Mixamo_Converter软件，获取体重提供的角色3D模型，将其导入到Mixamo网站</p><p>选择3种舞蹈动画进行下载，再使用Mixamo_Converter软件将下载的fbx准换为UE4可以使用的格式</p><p>将转换好后的动画素材导入到UE4中，为官方小白人模型的动画</p><p><img src="./src/%E5%B0%8F%E7%99%BD%E4%BA%BA%E5%8A%A8%E7%94%BB.png"/></p><h5>骨骼重定向</h5><p>重定向原项目人物骨骼，对比两个骨骼位置，全部手动添加并调试</p><p>(花费了大量时间😭，不一一列举)</p><p><img src="./src/%E9%AA%A8%E9%AA%BC%E9%87%8D%E5%AE%9A%E5%90%91.png"/></p><p>再将骨骼节点的 Translation Retarget 选项慢慢调试：为动画或骨骼</p><p><img src="./src/Translation_Retarget.png"/></p><p>经过漫长的调参，尽量保证重定向后骨骼动画不至于拉伸严重</p><p>最后终于到了重定向骨骼的一步</p><p><img src="./src/%E9%87%8D%E5%AE%9A%E5%90%91%E6%93%8D%E4%BD%9C.png"/></p><p>得到相对较好的动画资源</p><p>将动画资源转为Montage，并且Slot设置为Full Body，并且改为根骨骼移动(防止mesh和collision不在一个位置)</p><h5>设置输入、播放动画</h5><p>cpp中使蓝图能够调用<code>TogglePerspective()</code>，从而调节TPP和FPP视角；</p><pre><code class="language-cpp">UFUNCTION(BlueprintCallable)
void TogglePerspective();

UPROPERTY(BlueprintReadWrite)
bool IsFPP;
</code></pre><p>在人物蓝图中设置输入并播放动画</p><p>输入事件在Dance中播放Montage，并且在播放中禁止任何输入(防止出现边跳舞边开枪的bug)delay相应的跳舞时间后启用输入操作</p><p>整体蓝图如下所示</p><p><img src="./src/%E4%BA%BA%E7%89%A9Dance%E8%93%9D%E5%9B%BE.png"/></p><p>Dance方法实现如下，设置必要的状态参数，并且在播放动画时自动切换第三人称</p><p><img src="./src/Dance%E6%96%B9%E6%B3%95.png"/></p><p>实现了按键播放人物动画，3D UI 启用动画在UMG中有详细解释</p><h3>功能二</h3><p>主角静止无输入5秒之后进入idle休闲动画，如耸肩、挠头等</p><h4>实现效果</h4><p>主角静止无输入5秒之后进入耸肩动画，同一无操作间隔内只进行一次，且不会与其他动画冲突</p><p><img src="./src/%E8%80%B8%E8%82%A9.png"/></p><h4>解决办法</h4><p>同功能一步骤制作蒙太奇<strong>耸肩动画</strong></p><p><img src="./src/%E8%80%B8%E8%82%A9%E5%8A%A8%E7%94%BB.png"/></p><p>Tcik计时，无数入进行5秒后，播放耸肩动画，有输入就停止播放</p><ul><li>跳舞时间内不会播放耸肩动画</li><li>下蹲时不会播放</li></ul><p><img src="./src/%E8%80%B8%E8%82%A9%E8%93%9D%E5%9B%BE.png"/></p><h3>功能三</h3><p>蹲姿及其配套的基础移动动作</p><h4>实现效果</h4><p>（动画重定向，手臂位置拉伸太大，功能都已实现，动画不适配的bug还未能修复😭）</p><p>人物按Z键能够实现蹲姿，同时减慢移动速度和减少胶囊体半高</p><p><img src="./src/%E8%B9%B2%E5%A7%BF.png"/></p><h4>解决办法</h4><p>人物移动组件Character movement 中勾选<strong>can crouch</strong> ✔️</p><p>修改<strong>移动速度</strong></p><p>（漫长的找素材过程，很遗憾骨骼重定向后人物手臂位置拉伸还是很严重）</p><p>通过蹲姿前进、后退、左移、右移等动画制作<strong>混合空间</strong>，设置横纵轴的参数和范围，横轴用来确定方向，纵轴对应人物移动速度</p><p><img src="./src/%E8%B9%B2%E5%A7%BF%E6%B7%B7%E5%90%88%E7%A9%BA%E9%97%B4%E8%BD%B4.png"/></p><p><img src="./src/%E6%B7%B7%E5%90%88%E7%A9%BA%E9%97%B4.png"/></p><p><strong>人物事件蓝图</strong>中设置<strong>按键Z进行下蹲</strong>，并相应的改变FPP相机高度和胶囊体半高</p><p><img src="./src/%E8%B9%B2%E5%A7%BF%E4%BA%8B%E4%BB%B6%E8%93%9D%E5%9B%BE.png"/></p><p>动画蓝图中新建<strong>Crouch状态机</strong>，Entry直连Crouch状态，设置对应的输入值</p><p><img src="./src/Crouch%E7%8A%B6%E6%80%81%E6%9C%BA.png"/></p><p>将原动画缓存为 SavedPose_OriginMovement ，Crouch状态机缓存为 SavedPose_Crouch ，使用波尔值Is Crouch和Blend Poses by Bool节点Blend动画</p><p>​	<img src="./src/%E6%B7%B7%E5%90%88%E8%B9%B2%E5%A7%BF%E5%8A%A8%E7%94%BB.png"/></p><p>实现按Z轴切换蹲姿和站立，不同方向的混合移动动画</p><h3>功能四</h3><p>停步动作，并优化其衔接表现</p><h4>实现效果</h4><p>添加跑动结束停步动画</p><h4>解决办法</h4><p>导入两只脚的停步动画</p><p>定义变量Is Right Foot 用于判断当前为哪只脚准备着地</p><p>在跑步动画关键帧中设置Notify事件RightFoot、LeftFoot</p><p><img src="./src/%E8%B7%91%E6%AD%A5%E9%80%9A%E7%9F%A5%E4%BA%8B%E4%BB%B6.png"/></p><p>在动画蓝图中用Notify事件给Is Right Foot 赋值</p><p><img src="./src/Notify.png"/></p><p>在状态机中添加一个状态,并设置相应的转换条件，当Speed&lt;100.0f时进入动画</p><p><img src="./src/%E8%B7%91%E5%8A%A8%E7%8A%B6%E6%80%81%E6%9C%BA.png"/></p><p>（导入的动画和跑步动画不适配，表现比较僵硬）</p><h3>功能五</h3><p>脚部的IK功能</p><h4>实现效果</h4><p>实现<strong>脚步IK功能</strong>，人物踏入不同高度的地面脚部会放置在不同高度（稍微有些内八）</p><p><img src="./src/%E8%84%9A%E6%AD%A5IK.png"/></p><p><img src="./src/%E5%89%8D%E8%A7%86%E5%9B%BE.png"/></p><p>并且脚面能够进行<strong>旋转，从而贴合地面</strong></p><p><img src="./src/%E8%84%9A%E6%AD%A5%E6%97%8B%E8%BD%AC.png"/></p><h4>解决办法</h4><p>在角色左右脚骨骼添加插槽名为&quot;<code>LeftFootSocket</code>&quot;、&quot;<code>RightFootSocket</code>&quot;，为了后续获得此点的坐标信息；</p><p><img src="./src/Socket.png"/></p><p>构造函数中确定部分定义变量的值</p><ul><li><code>Scale</code>：角色比例</li><li><code>Foot Offset</code>：脚部插槽位置和脚底位置的差，用于解决脚部骨骼的位置并不在脚后跟的下面导致的脚步下陷问题</li><li><code>Capsule Half Height</code>：初始胶囊体半高，用于后续修改胶囊体半长，防止角色上方空出碰撞部分</li></ul><p><img src="./src/IK%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0.png"/></p><p>通过射线检测，确定角色脚部需要抬高的偏移量，从而确定角色的脚实际应该摆放的位置。</p><p>角色蓝图中 PlayerPawn 中声明并定义<code>IK Foot Trace</code>方法，输入插槽名称和射线长度<code>TraceDistance</code>，世界坐标下向脚步下方插槽位置发射一条垂直射线，并返回<code>IKOffset</code>(脚部偏移量)</p><p><img src="./src/IK_Foot_Trace.png"/></p><p>角色Event Graph中， Event Tick 调用<code>IK Foot Trace</code>方法，将返回值Lerp后存入<code>IKoffsetRightFoot</code>、<code>IKoffsetLeftFoot</code>(插值左右脚实际该偏移的长度)中，使值平滑变动。 </p><p><img src="./src/%E8%8E%B7%E5%8F%96%E8%84%9A%E6%AD%A5Offset.png"/></p><p>获得了上述变量值，进而在动画蓝图中使用两个<strong>Two Bone IK</strong>节点，设置两个节点的<code>IKBone</code>、<code>Effector</code>、<code>Joint Target</code>，确保坐标空间为<code>Bone Space</code>,图中展示右脚部分的设置，左脚同理</p><p><img src="./src/Two_Bone_IK.png"/></p><p><img src="./src/Two_Bone_IK%E8%AE%BE%E7%BD%AE.png"/></p><p>在动画蓝图中定义<code>RightFootEffectorLocation</code>、<code>LeftFootEffectorLocation</code>，根据之前求出的左右脚偏移量，将其作为X值，赋值<code>RightFootEffectorLocation</code>、<code>LeftFootEffectorLocation</code>，根据左右脚的坐标系不同，确定两个变量的X值正负（因为根据的坐标系是基于左右脚的，脚部竖直向上位移的时候，变化的是Effector Location—X轴，并且左右脚还是相反的）</p><p><img src="./src/%E8%8E%B7%E5%BE%97Effector_Location.png"/></p><hr/><p><strong>解决角色被碰撞体挡住，不能进行脚步IK问题：</strong></p><p>在碰撞体宽度大的情况下，物体骨骼无法到达下一台阶的位置，也无法使用实现IK，通过<strong>把整体骨骼拉到下一级台阶，同时缩小胶囊体的半高</strong>解决</p><p>定义<code>Mesh Offset Z</code>变量，其值通过左右脚偏移量做差取绝对值负数获得，从而确定整体骨骼向下的偏移量，使用Transform(Modify) Bone节点将整体骨骼位置拉低，节点控制根骨骼在世界坐标的偏移。</p><p><img src="./src/Transform_Bone.png"/></p><p>拉低根骨骼的同时，人物上方会空出碰撞区域，同时根据<code>Mesh Offset Z</code>将碰撞体半场高修改解决问题</p><p><img src="./src/%E4%BF%AE%E6%94%B9%E5%8D%8A%E5%9C%BA%E9%AB%98.png"/></p><hr/><p><strong>解决脚部插槽高度与脚底高度不同，脚陷入问题：</strong></p><p>在脚底新建插槽，计算插槽与脚部插槽的高度差值<code>FootOffset</code>，在偏移量中加入此值，解决脚部有点陷入地面问题</p><hr/><p><strong>实现脚面贴合不同角度平面：</strong></p><p>在动画蓝图中添加两个<code>Transform（Modify）Bone</code>节点，用来更改左右脚的<code>Rotation</code>，将其分别关联在两只脚的骨骼上，并且在世界坐标下旋转</p><p><img src="./src/%E6%94%B9%E5%8F%98%E8%84%9A%E9%83%A8%E8%A7%92%E5%BA%A6%E8%93%9D%E5%9B%BE.png"/></p><p>根据射线HitResult的法向量信息，求解脚部该旋转的Rotator</p><p><img src="./src/%E5%9B%BE%E8%A7%A3%E8%84%9A%E9%83%A8%E6%97%8B%E8%BD%AC%E8%A7%92%E5%BA%A6.jpg"/></p><p><img src="./src/%E6%B1%82%E6%97%8B%E8%BD%AC%E8%A7%92.png"/></p><p>将值赋给<code>Transform（Modify）Bone</code>节点的Rotation，实现脚面贴合不同角度平面</p><p><img src="./src/%E8%84%9A%E9%83%A8%E6%97%8B%E8%BD%ACIK.png"/></p><p>整体动画蓝图</p><p><img src="./src/%E6%95%B4%E4%BD%93%E5%8A%A8%E7%94%BB%E8%93%9D%E5%9B%BE.png"/></p><hr/><h2>渲染基础</h2><h3>功能一</h3><p>使用标准材质，把场景地面修改为砖块或木板等均可</p><h4>实现效果</h4><p>将地图中一块地面的材质修改为橡木板材质</p><p><img src="./src/%E6%A9%A1%E6%9C%A8%E5%9C%B0%E6%9D%BF.png"/></p><h4>解决办法</h4><p>将此地板的材质—Element2替换为初学者内容包的M_Wood_Oak</p><p><img src="./src/%E6%9D%90%E8%B4%A8%E9%9D%A2%E6%9D%BF.png"/></p><hr/><h3>功能二</h3><p>使用标准材质，把枪械修改为金属</p><h4>实现效果</h4><p><img src="./src/%E9%87%91%E5%B1%9E%E6%AD%A6%E5%99%A8.png"/></p><h4>解决办法</h4><ul><li><p>将武器的主体材质替换为标准材质<code>M_Metal_Burnished_Steel</code>金属材质;</p></li><li><p>武器瞄准镜部分替换为标准材质<code>M_Metal_Steel</code>金属材质;</p></li></ul><p><img src="./src/%E6%AD%A6%E5%99%A8%E6%9D%90%E8%B4%A8.png"/></p><h3>功能三</h3><p>添加一种后处理效果</p><h4>实现效果</h4><p>自定义玻璃材质，修改静态网格体 MainHall_WallGrass_05 的材质，实现屏幕空间反射的后处理效果</p><p><img src="./src/%E7%8E%BB%E7%92%83%E6%95%88%E6%9E%9C.png"/></p><h4>解决办法</h4><p>新建材质Glass，设置参数基础颜色、metallic和粗糙度</p><p><img src="./src/Glass.png"/></p><p>生成实例Glass_Inst，赋值颜色为灰色</p><p><img src="./src/Glass_Ins.png"/></p><p>再生成实例Glass_Inst_Inst并赋值颜色Metallic为1.0，实现屏幕空间反射效果</p><p><img src="./src/Glass_Inst_Inst.png"/></p><p><img src="./src/%E5%B1%8F%E5%B9%95%E7%A9%BA%E9%97%B4%E5%8F%8D%E5%B0%84%E6%9D%90%E8%B4%A8%E7%90%83.png"/></p><h3>功能四</h3><p>使用材质编辑器，添加至少一种自定义材质，比如枪械上的UV动画</p><h4>实现效果</h4><ol><li>将两种枪械的瞄准镜部分添加了UV动画，使枪械表面产生流动的效果</li></ol><p><img src="./src/%E7%9E%84%E5%87%86%E9%95%9CUV%E5%8A%A8%E7%94%BB.png"/></p><ol start="2"><li>自定义半透明材质，物体穿过会将轮廓绘制并描绘出亮边</li></ol><p><img src="./src/%E8%87%AA%E5%AE%9A%E4%B9%89%E9%98%B2%E5%BE%A1%E6%9D%90%E8%B4%A8.png"/></p><p>将材质实例应用到Cube上囊括玩家出生点房间，子弹射线不会检测到其中的玩家，但是玩家能够正常穿过这道门，实现<strong>保护玩家在出生点不受外部子弹伤害</strong>的一种机制</p><p><img src="./src/%E5%B0%84%E5%87%BB%E9%98%B2%E5%BE%A1%E6%9D%90%E8%B4%A8.png"/></p><h4>解决办法</h4><ol><li>在武器材质蓝图中，给枪械瞄准镜部分纹理添加Panner节点，速度X设置为0.1，从而实现流动效果</li></ol><p><img src="./src/%E6%AD%A6%E5%99%A8%E6%9D%90%E8%B4%A8UV%E5%8A%A8%E7%94%BB.png"/></p><ol start="2"><li><p>新建自定义材质，命名为<strong>&quot;Transparency&quot;</strong></p><ul><li>混合模式 为 &quot;半透明&quot;</li><li>着色模型 为 &quot;无光照&quot;</li></ul><p>材质蓝图中创建各节点和参数并连接</p><p><img src="./src/%E9%98%B2%E5%BE%A1%E6%9D%90%E8%B4%A8%E8%93%9D%E5%9B%BE.png"/></p><p>生成材质实例，并在实例中将各个参数启用并赋值</p><ul><li>Depth：亮边宽度</li><li>Color：原色</li><li>Depth_Color：高亮颜色</li></ul><p><img src="./src/%E9%98%B2%E5%BE%A1%E6%9D%90%E8%B4%A8%E5%AE%9E%E4%BE%8B%E5%8F%82%E6%95%B0.png"/></p><p>实现如下效果</p><p><img src="./src/%E5%9C%86%E5%BC%A7%E5%8B%BE%E5%8B%92%E8%BD%AE%E5%BB%93.png"/></p><p>最后将材质添加到Cube上，Cube囊括玩家出生地，当有玩家穿过能够高亮轮廓，外面的子弹无法打进出生地，实现一种出生保护机制。</p></li></ol><h3>功能五</h3><p>结合游戏玩法丰富技能特效，比如开火、击中或爆炸特效等</p><h4>实现效果</h4><p>被击杀的玩家能够不是直接消失，而是先实现消融的材质特效再销毁</p><p><img src="./src/Pawn%E6%BA%B6%E8%A7%A3.png"/></p><h4>解决办法</h4><p>在人物材质的Blend Mode置为Masked，修改并赋值<code>EmissiveColor</code>、<code>OpacityMask</code>节点，将Value参数控制溶解程度，编写材质函数Sine_remapped、MF_Appearacne和材质蓝图，调参实现溶解效果</p><p><img src="./src/%E6%BA%B6%E8%A7%A3%E6%9D%90%E8%B4%A8%E8%93%9D%E5%9B%BE.png"/></p><p>Sine_remapped材质函数</p><p><img src="./src/Sine_remapped.png"/></p><p>MF_Appearacne材质函数</p><p><img src="./src/MF_Appearance%E8%93%9D%E5%9B%BE.png"/></p><p>基于此材质生成材质实例 HeroTPP_Inst，将Pawn的材质替换；</p><p>在ShooterCharacter.h中声明函数<code>LetPawnDissolve()</code>，使其控制溶解速度</p><pre><code class="language-cpp">public:
    UFUNCTION(BlueprintImplementableEvent)
        void LetPawnDissolve();
</code></pre><p>蓝图中重写<code>LetPawnDissolve</code>，延迟五秒后，使用TimeLine实现材质参数根据定义的时间线变化。</p><p><img src="./src/EventLetPawnDissolve.png"/></p><p>人物死亡时调用OnDeath()函数，所以在cpp <code>AShooterCharacter::onDeath()</code>函数中调用蓝图方法LetPawnDissolve()</p><pre><code class="language-cpp">void AShooterCharacter::OnDeath(...){
    ...
    LetPawnDissolve();
    ...
}
</code></pre><p>实现人物在死亡后，出现缓慢溶解的特效，再销毁物体</p><p><img src="./src/Pawn%E6%BA%B6%E8%A7%A32.png"/></p><hr/><h2>AI技术介绍</h2><h3>功能一</h3><p>通过设置NavMeshBoundsVolume生成地图的导航网格</p><h4>实现效果</h4><p>通过构建网格体边界体积（Navigation Mesh Bounds Volume），实现地图的导航网格</p><p><img src="./src/%E5%AF%BC%E8%88%AA%E7%BD%91%E6%A0%BC.png"/></p><h4>解决办法</h4><p>添加<strong>寻路网格体边界体积（Navigation Mesh Bounds Volume）</strong></p><p>解决寻路网格体在高度上绘制出现偏差问题，调整绘制寻路网格体的高度偏移将<code>RecastNavMesh-Common ———— Draw offset </code>设置为10.0f</p><h3>功能二</h3><p>基于生成的导航网格让角色从两点间自动寻路</p><h4>实现效果</h4><p>AI角色能够在两点间自动寻路，在到达一个目标点后延迟3秒</p><p><img src="./src/%E8%87%AA%E5%8A%A8%E5%AF%BB%E8%B7%AFA.png"/></p><p><img src="./src/%E8%87%AA%E5%8A%A8%E5%AF%BB%E8%B7%AFB.png"/></p><h4>解决办法</h4><p>在BotPawn的事件蓝图中添加MoveToA、MoveToB自定义事件，使用<code>AI Move To</code>节点，互相调用事件，实现AI角色从A坐标和B坐标基于导航网格来回移动寻路。</p><p><img src="./src/%E8%87%AA%E5%8A%A8%E5%AF%BB%E8%B7%AF%E8%93%9D%E5%9B%BE.png"/></p><h3>功能三</h3><p>在UE4中创建黑板，行为树以及行为树装饰器</p><h4>实现效果</h4><p>为AI角色创建黑板、行为树及装饰器等等</p><p>AI角色主要有三种行为：</p><ol><li>填充弹药：寻找最近子弹位置，移动到最近的子弹填充处进行子弹填充</li><li>发现敌人并攻击：如果视野内存在敌人，追逐敌人并攻击</li><li>未发现敌人/闲置状态：随机选定巡逻点并移动，实现随机巡逻</li></ol><p><img src="./src/%E8%A1%8C%E4%B8%BA%E6%A0%91%E6%80%BB%E8%A7%88.png"/></p><p>黑板关键帧</p><ul><li>Enemy<code>(Object)</code>：当前目标敌人，基类ShooterCharacter</li><li>NeedAmmo<code>(Bool)</code>：是否需要子弹，用于判定AI角色子弹是否充裕</li><li>Destination<code>(Vector)</code>：当前的目的地，可以是追逐玩家的位置、随机巡逻点或子弹填充地</li><li>SelfActor<code>(Object)</code>：自己</li><li>HasPlayerInSight<code>(Bool)</code>：在AI角色视线内是否存在敌人</li></ul><p><img src="./src/%E9%BB%91%E6%9D%BF%E6%80%BB%E8%A7%88.png"/></p><h4>解决办法</h4><p>后续功能将会相应部分的实现进行解释</p><h3>功能四</h3><p>使用行为树的基本节点（选择器、序列节点、平行节点等）以及角色移动组件实现NPC追逐玩家的任务</p><h4>实现效果</h4><p>AI角色在感知并发现敌人后，能够对发现目标进行追逐并攻击</p><p><img src="./src/%E8%BF%BD%E9%80%90%E7%8E%A9%E5%AE%B6.png"/></p><h4>解决办法</h4><p>由根连接一个Selector，其上挂载<code>BotSearchEnemyLOS</code>和<code>Shoot An Enemy</code>两个服务</p><p><img src="./src/%E8%A1%8C%E4%B8%BA%E6%A0%91%E6%A0%B9.png"/></p><ul><li><p>BotSearchEnemyLOS服务：间隔0.5s，调用ShooterAIController中的cpp方法，找到距离最近的Enemy并且给黑板键<code>Enemy</code>赋值，将其设置为当前目标</p></li><li><p>BotShooeEnemy服务：调用<code>AShooterAIController::ShootEnemy()</code>，根据黑板健<code>Enemy</code>、敌人是否存活、当前弹药值等条件判断是否能够进行射击，并且赋值<code>bCanShoot</code>变量，间隔0.5s发射子弹</p><pre><code class="language-cpp">void AShooterAIController::ShootEnemy()
{
    ...
   bool bCanShoot = false;
   AShooterCharacter* Enemy = GetEnemy();
   if ( Enemy &amp;&amp; ( Enemy-&gt;IsAlive() )&amp;&amp; (MyWeapon-&gt;GetCurrentAmmo() &gt; 0) &amp;&amp; ( MyWeapon-&gt;CanFire() == true ) )
   {
      if (LineOfSightTo(Enemy, MyBot-&gt;GetActorLocation()))
      {
         bCanShoot = true;
      }
   }
   if (bCanShoot)
   {
      MyBot-&gt;StartWeaponFire();
   }
   else
   {
      MyBot-&gt;StopWeaponFire();
   }
}
</code></pre></li></ul><p>如果黑板的键<code>Enemy</code>已设置并且AI感知到敌人在视野之内，说明<strong>发现敌人</strong>，将进入到攻击序列Attack Sequence</p><p>在Find Point Near Enemy 任务中找到最近的敌人附近的位置，更新黑板的<code>Destination</code>值，<strong>获得AI角色该到达的<u>目的地</u></strong>(敌人附近)</p><p>Move To Enemy 任务<strong>跟随</strong>并攻击玩家，直至玩家死亡。</p><p><img src="./src/%E5%90%91%E6%95%8C%E4%BA%BA%E7%A7%BB%E5%8A%A8.png"/></p><h3>功能五</h3><p>基于行为树和AI感知组件实现随机巡逻任务</p><h4>实现效果</h4><p>(原项目只要地图中存在玩家，就会自动寻路找到玩家并攻击)</p><p>AI角色在没有感知到敌人时，进行随机巡逻，当视线内出现敌人后才开始进行攻击和追逐行为</p><p><img src="./src/%E9%9A%8F%E6%9C%BA%E5%B7%A1%E9%80%BB.png"/></p><h4>解决办法</h4><p>行为树中添加新的序列用于随机巡逻，添加两个<strong>装饰器</strong>(继承于BT装饰器蓝图基础)</p><ol><li><strong>RandomDes装饰器</strong>：用于找寻随机点，让AI角色进行随即巡逻</li></ol><p>​	根据Actor位置，连接<code>GetRandomReachablePointInRadius</code>节点，将返回值赋给Destination黑板键后完成执行</p><p><img src="./src/RandomDes.png"/></p><ol start="2"><li><strong>FindPlayer装饰器</strong>：重写Perform Condition Check AI，将BotPawn中的<code>Is Find Player</code>赋值给黑板键<code>Is Find Player</code></li></ol><p><img src="./src/RandomDes.png"/></p><p>将FindPlayer装饰器添加进攻击敌人的选择器中，如果视线内不存在敌人则不会进行攻击序列</p><p>为玩家角色蓝图添加<strong>AI感知刺激源组件</strong></p><p>给AI角色添加<strong>AI感知组件</strong>：视觉感知器官，对参数进行修改，归属检测全部选中</p><p><img src="./src/AI%E6%84%9F%E7%9F%A5%E7%BB%84%E4%BB%B6.png"/></p><p>定义<code>On Target Perception Updated</code>，如果感知到敌方并且为玩家，则设置Is Find Player为true</p><p><img src="./src/OnTargetPerceptionUpdated.png"/></p><p>实现AI通过视觉发现目标后去追随目标并进入攻击序列</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[搭建Docusaurus教程]]></title>
            <link>https://gai-zi.github.io/Website/blog/搭建Docusaurus教程</link>
            <guid>搭建Docusaurus教程</guid>
            <pubDate>Fri, 07 Jan 2022 03:03:44 GMT</pubDate>
            <description><![CDATA[此教程为傻瓜式搭建Docusaurus个人网站并部署在Github Pages上]]></description>
            <content:encoded><![CDATA[<p>此教程为<strong>傻瓜式</strong>搭建Docusaurus个人网站并部署在Github Pages上</p><h2>前提准备</h2><ul><li><p><a href="https://nodejs.org/en/download/">Node.js</a> 版本 &gt;= 14</p><p><code>node -v</code></p></li><li><p><a href="https://yarnpkg.com/en/">Yarn</a> 版本 &gt;= 1.5</p><p><code>yarn --version</code> </p></li></ul><h2>安装项目脚手架</h2><p>创建一个名为<code>website</code>的项目，使用 <code>classic</code> 模板</p><pre><code class="language-bash">$ npx create-docusaurus@latest Website classic
</code></pre><h2>运行服务器</h2><pre><code class="language-bash">$ yarn run start
</code></pre><p>默认情况下，浏览器将自动打开 http://localhost:3000 的新窗口</p><blockquote><p>若运行不成功，尝试使用<code>yarn add docusaurus --dev</code>或<code>yarn global add docusaurus --dev</code>命令</p></blockquote><h2>发布到Github Pages</h2><h3>Git仓库配置</h3><p>Git新建<code>Website</code>仓库，同步本地<code>Website</code>文件夹</p><p>新建gh-pages分支，用于存放前端展示的内容</p><p>Settings-Pages-Source改为gh-pages</p><p>![](./pages source.png)</p><h3>修改配置文件</h3><p>修改<code>docusaurus.config.js</code></p><pre><code class="language-js">module.exports = {
    title: &#x27;Blog &amp; Document&#x27;,           //站点名称
    tagline: &#x27;gai-zi&#x27;,                  //标语
    url: &#x27;https://gai-zi.github.io&#x27;,    //站点地址
    baseUrl: &#x27;/Website/&#x27;,               //前置路径
    onBrokenLinks: &#x27;throw&#x27;,             //编译遇到死链怎么处理
    onBrokenMarkdownLinks: &#x27;warn&#x27;,
    favicon: &#x27;img/favicon.ico&#x27;,         // 网站的图标
    organizationName: &#x27;gai-zi&#x27;,         // GitHub 上的组织名或者用户名
    projectName: &#x27;Website&#x27;,             // GitHub 上仓库的名称
    ...
}
</code></pre><h3>发布</h3><p>运行以下命令，会自动将本地项目打包发布到gh-pages分支</p><pre><code class="language-bash">$ cmd /C &#x27;set &quot;GIT_USER=gai-zi&quot; &amp;&amp; yarn deploy&#x27;
</code></pre><blockquote><p>若期间clone卡死，可以尝试取消代理</p></blockquote><p>本地查看<code>npm run serve</code></p><hr/><p>演示地址：<a href="https://gai-zi.github.io/Website">https://gai-zi.github.io/Website</a></p><p>源码：<a href="https://github.com/gai-zi/Website">gai-zi/Website (github.com)</a></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Welcome]]></title>
            <link>https://gai-zi.github.io/Website/blog/welcome</link>
            <guid>welcome</guid>
            <pubDate>Wed, 06 Jan 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[欢迎您大驾光临！]]></description>
            <content:encoded><![CDATA[<p>欢迎您大驾光临！</p><p><img src="./%E4%B8%BA%E4%BA%BA%E6%B0%91%E6%9C%8D%E5%8A%A1.png"/></p>]]></content:encoded>
        </item>
    </channel>
</rss>